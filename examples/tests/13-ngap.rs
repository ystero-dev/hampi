#![allow(dead_code, unreachable_patterns, non_camel_case_types)]
use bitvec::order::Msb0;
use bitvec::vec::BitVec;

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AMF_TNLAssociationSetupItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AMF_TNLAssociationSetupItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationSetupList(pub Vec<AMF_TNLAssociationSetupItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AMF_TNLAssociationToAddItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_usage: Option<TNLAssociationUsage>,
    pub tnl_address_weight_factor: TNLAddressWeightFactor,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AMF_TNLAssociationToAddItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToAddList(pub Vec<AMF_TNLAssociationToAddItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AMF_TNLAssociationToRemoveItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AMF_TNLAssociationToRemoveItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToRemoveList(pub Vec<AMF_TNLAssociationToRemoveItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AMF_TNLAssociationToUpdateItem {
    pub amf_tnl_association_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_usage: Option<TNLAssociationUsage>,
    #[asn(optional_idx = 1)]
    pub tnl_address_weight_factor: Option<TNLAddressWeightFactor>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<AMF_TNLAssociationToUpdateItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct AMF_TNLAssociationToUpdateList(pub Vec<AMF_TNLAssociationToUpdateItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1099511627775")]
pub struct AMF_UE_NGAP_ID(pub u64);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFCPRelocationIndication {
    pub protocol_i_es: AMFCPRelocationIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdate {
    pub protocol_i_es: AMFConfigurationUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdateAcknowledge {
    pub protocol_i_es: AMFConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFConfigurationUpdateFailure {
    pub protocol_i_es: AMFConfigurationUpdateFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct AMFName(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "UTF8String", sz_extensible = true, sz_lb = "1", sz_ub = "150")]
pub struct AMFNameUTF8String(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "VisibleString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct AMFNameVisibleString(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum AMFPagingTarget {
    #[asn(key = 0, extended = false)]
    GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 1, extended = false)]
    TAI(TAI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(AMFPagingTargetchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "6", sz_ub = "6")]
pub struct AMFPointer(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct AMFRegionID(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct AMFSetID(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct AMFStatusIndication {
    pub protocol_i_es: AMFStatusIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AdditionalDLUPTNLInformationForHOItem {
    pub additional_dl_ngu_up_tnl_information: UPTransportLayerInformation,
    pub additional_qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    #[asn(optional_idx = 0)]
    pub additional_dl_forwarding_uptnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AdditionalDLUPTNLInformationForHOItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct AdditionalDLUPTNLInformationForHOList(pub Vec<AdditionalDLUPTNLInformationForHOItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AdditionalQosFlowInformation(pub u8);
impl AdditionalQosFlowInformation {
    pub const MORE_LIKELY: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllocationAndRetentionPriority {
    pub priority_level_arp: PriorityLevelARP,
    pub pre_emption_capability: Pre_emptionCapability,
    pub pre_emption_vulnerability: Pre_emptionVulnerability,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Allowed_CAG_List_per_PLMN(pub Vec<CAG_ID>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Allowed_PNI_NPN_Item {
    pub plmn_identity: PLMNIdentity,
    pub pni_npn_restricted: ENUMERATED_2,
    pub allowed_cag_list_per_plmn: Allowed_CAG_List_per_PLMN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Allowed_PNI_NPN_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct Allowed_PNI_NPN_List(pub Vec<Allowed_PNI_NPN_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AllowedNSSAI(pub Vec<AllowedNSSAI_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllowedNSSAI_Item {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllowedNSSAI_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AllowedTACs(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "8", extensible = true)]
pub struct AlternativeQoSParaSetIndex(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct AlternativeQoSParaSetItem {
    pub alternative_qo_s_para_set_index: AlternativeQoSParaSetIndex,
    #[asn(optional_idx = 0)]
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    #[asn(optional_idx = 2)]
    pub packet_delay_budget: Option<PacketDelayBudget>,
    #[asn(optional_idx = 3)]
    pub packet_error_rate: Option<PacketErrorRate>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<AlternativeQoSParaSetItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AlternativeQoSParaSetList(pub Vec<AlternativeQoSParaSetItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "8", extensible = true)]
pub struct AlternativeQoSParaSetNotifyIndex(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct AreaOfInterest {
    #[asn(optional_idx = 0)]
    pub area_of_interest_tai_list: Option<AreaOfInterestTAIList>,
    #[asn(optional_idx = 1)]
    pub area_of_interest_cell_list: Option<AreaOfInterestCellList>,
    #[asn(optional_idx = 2)]
    pub area_of_interest_ran_node_list: Option<AreaOfInterestRANNodeList>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<AreaOfInterestIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestCellItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestCellItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct AreaOfInterestCellList(pub Vec<AreaOfInterestCellItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestItem {
    pub area_of_interest: AreaOfInterest,
    pub location_reporting_reference_id: LocationReportingReferenceID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AreaOfInterestList(pub Vec<AreaOfInterestItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestRANNodeItem {
    pub global_ran_node_id: GlobalRANNodeID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestRANNodeItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AreaOfInterestRANNodeList(pub Vec<AreaOfInterestRANNodeItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AreaOfInterestTAIItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AreaOfInterestTAIItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct AreaOfInterestTAIList(pub Vec<AreaOfInterestTAIItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum AreaScopeOfMDT_EUTRA {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT_EUTRA),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(NULL_3),
    #[asn(key = 3, extended = false)]
    TAIBased(TAIBasedMDT),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(AreaScopeOfMDT_EUTRAchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum AreaScopeOfMDT_NR {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT_NR),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(NULL_4),
    #[asn(key = 3, extended = false)]
    TAIBased(TAIBasedMDT),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(AreaScopeOfMDT_NRchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AreaScopeOfNeighCellsItem {
    pub nr_frequency_info: NRFrequencyInfo,
    #[asn(optional_idx = 0)]
    pub pci_list_for_mdt: Option<PCIListForMDT>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AreaScopeOfNeighCellsItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct AreaScopeOfNeighCellsList(pub Vec<AreaScopeOfNeighCellsItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct AssistanceDataForPaging {
    #[asn(optional_idx = 0)]
    pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
    #[asn(optional_idx = 1)]
    pub paging_attempt_information: Option<PagingAttemptInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<AssistanceDataForPagingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForRecommendedCells {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct AssociatedQosFlowItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub qos_flow_mapping_indication: Option<ENUMERATED_5>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<AssociatedQosFlowItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct AssociatedQosFlowList(pub Vec<AssociatedQosFlowItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct AuthenticatedIndication(pub u8);
impl AuthenticatedIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095", extensible = true)]
pub struct AveragingWindow(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4000000000000", extensible = true)]
pub struct BitRate(pub u64);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasConfig(pub u8);
impl BluetoothMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BluetoothMeasConfigNameItem {
    pub bluetooth_name: BluetoothName,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<BluetoothMeasConfigNameItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BluetoothMeasConfigNameList(pub Vec<BluetoothMeasConfigNameItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    #[asn(optional_idx = 0)]
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub bt_rssi: Option<ENUMERATED_6>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BluetoothName(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "6", extensible = false)]
pub enum BroadcastCancelledAreaList {
    #[asn(key = 0, extended = false)]
    CellIDCancelledEUTRA(CellIDCancelledEUTRA),
    #[asn(key = 1, extended = false)]
    TAICancelledEUTRA(TAICancelledEUTRA),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDCancelledEUTRA(EmergencyAreaIDCancelledEUTRA),
    #[asn(key = 3, extended = false)]
    CellIDCancelledNR(CellIDCancelledNR),
    #[asn(key = 4, extended = false)]
    TAICancelledNR(TAICancelledNR),
    #[asn(key = 5, extended = false)]
    EmergencyAreaIDCancelledNR(EmergencyAreaIDCancelledNR),
    #[asn(key = 6, extended = false)]
    Choice_Extensions(BroadcastCancelledAreaListchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "6", extensible = false)]
pub enum BroadcastCompletedAreaList {
    #[asn(key = 0, extended = false)]
    CellIDBroadcastEUTRA(CellIDBroadcastEUTRA),
    #[asn(key = 1, extended = false)]
    TAIBroadcastEUTRA(TAIBroadcastEUTRA),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDBroadcastEUTRA(EmergencyAreaIDBroadcastEUTRA),
    #[asn(key = 3, extended = false)]
    CellIDBroadcastNR(CellIDBroadcastNR),
    #[asn(key = 4, extended = false)]
    TAIBroadcastNR(TAIBroadcastNR),
    #[asn(key = 5, extended = false)]
    EmergencyAreaIDBroadcastNR(EmergencyAreaIDBroadcastNR),
    #[asn(key = 6, extended = false)]
    Choice_Extensions(BroadcastCompletedAreaListchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct BroadcastPLMNItem {
    pub plmn_identity: PLMNIdentity,
    pub tai_slice_support_list: SliceSupportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<BroadcastPLMNItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct BroadcastPLMNList(pub Vec<BroadcastPLMNItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct BurstArrivalTime(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct CAG_ID(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CEmodeBSupport_Indicator(pub u8);
impl CEmodeBSupport_Indicator {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CEmodeBrestricted(pub u8);
impl CEmodeBrestricted {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CNAssistedRANTuning {
    #[asn(optional_idx = 0)]
    pub expected_ue_behaviour: Option<ExpectedUEBehaviour>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CNAssistedRANTuningIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct CNTypeRestrictionsForEquivalent(pub Vec<CNTypeRestrictionsForEquivalentItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CNTypeRestrictionsForEquivalentItem {
    pub plmn_identity: PLMNIdentity,
    pub cn_type: ENUMERATED_7,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CNTypeRestrictionsForEquivalentItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CNTypeRestrictionsForServing(pub u8);
impl CNTypeRestrictionsForServing {
    pub const EPC_FORBIDDEN: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueForPDCP_SN12 {
    pub pdcp_sn12: INTEGER_8,
    pub hfn_pdcp_sn12: INTEGER_9,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueForPDCP_SN12IE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueForPDCP_SN18 {
    pub pdcp_sn18: INTEGER_10,
    pub hfn_pdcp_sn18: INTEGER_11,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueForPDCP_SN18IE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum CPTransportLayerInformation {
    #[asn(key = 0, extended = false)]
    EndpointIPAddress(TransportLayerAddress),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(CPTransportLayerInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CancelAllWarningMessages(pub u8);
impl CancelAllWarningMessages {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_EUTRA(pub Vec<CancelledCellsInEAI_EUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInEAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInEAI_EUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_NR(pub Vec<CancelledCellsInEAI_NR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInEAI_NR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInEAI_NR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_EUTRA(pub Vec<CancelledCellsInTAI_EUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInTAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInTAI_EUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_NR(pub Vec<CancelledCellsInTAI_NR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellsInTAI_NR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellsInTAI_NR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CandidateCell {
    #[asn(key = 0, extended = false)]
    CandidateCGI(CandidateCellID),
    #[asn(key = 1, extended = false)]
    CandidatePCI(CandidatePCI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(CandidateCellchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidateCellID {
    pub candidate_cell_id: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidateCellIDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidateCellItem {
    pub candidate_cell: CandidateCell,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidateCellItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CandidateCellList(pub Vec<CandidateCellItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CandidatePCI {
    pub candidate_pci: INTEGER_12,
    pub candidate_nrarfcn: INTEGER_13,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CandidatePCIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "5", extensible = false)]
pub enum Cause {
    #[asn(key = 0, extended = false)]
    RadioNetwork(CauseRadioNetwork),
    #[asn(key = 1, extended = false)]
    Transport(CauseTransport),
    #[asn(key = 2, extended = false)]
    Nas(CauseNas),
    #[asn(key = 3, extended = false)]
    Protocol(CauseProtocol),
    #[asn(key = 4, extended = false)]
    Misc(CauseMisc),
    #[asn(key = 5, extended = false)]
    Choice_Extensions(Causechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct CauseMisc(pub u8);
impl CauseMisc {
    pub const CONTROL_PROCESSING_OVERLOAD: u8 = 0u8;
    pub const NOT_ENOUGH_USER_PLANE_PROCESSING_RESOURCES: u8 = 1u8;
    pub const HARDWARE_FAILURE: u8 = 2u8;
    pub const OM_INTERVENTION: u8 = 3u8;
    pub const UNKNOWN_PLMN_OR_SNPN: u8 = 4u8;
    pub const UNSPECIFIED: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CauseNas(pub u8);
impl CauseNas {
    pub const NORMAL_RELEASE: u8 = 0u8;
    pub const AUTHENTICATION_FAILURE: u8 = 1u8;
    pub const DEREGISTER: u8 = 2u8;
    pub const UNSPECIFIED: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct CauseProtocol(pub u8);
impl CauseProtocol {
    pub const TRANSFER_SYNTAX_ERROR: u8 = 0u8;
    pub const ABSTRACT_SYNTAX_ERROR_REJECT: u8 = 1u8;
    pub const ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY: u8 = 2u8;
    pub const MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE: u8 = 3u8;
    pub const SEMANTIC_ERROR: u8 = 4u8;
    pub const ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE: u8 = 5u8;
    pub const UNSPECIFIED: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "44")]
pub struct CauseRadioNetwork(pub u8);
impl CauseRadioNetwork {
    pub const UNSPECIFIED: u8 = 0u8;
    pub const TXNRELOCOVERALL_EXPIRY: u8 = 1u8;
    pub const SUCCESSFUL_HANDOVER: u8 = 2u8;
    pub const RELEASE_DUE_TO_NGRAN_GENERATED_REASON: u8 = 3u8;
    pub const RELEASE_DUE_TO_5GC_GENERATED_REASON: u8 = 4u8;
    pub const HANDOVER_CANCELLED: u8 = 5u8;
    pub const PARTIAL_HANDOVER: u8 = 6u8;
    pub const HO_FAILURE_IN_TARGET_5GC_NGRAN_NODE_OR_TARGET_SYSTEM: u8 = 7u8;
    pub const HO_TARGET_NOT_ALLOWED: u8 = 8u8;
    pub const TNGRELOCOVERALL_EXPIRY: u8 = 9u8;
    pub const TNGRELOCPREP_EXPIRY: u8 = 10u8;
    pub const CELL_NOT_AVAILABLE: u8 = 11u8;
    pub const UNKNOWN_TARGET_ID: u8 = 12u8;
    pub const NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL: u8 = 13u8;
    pub const UNKNOWN_LOCAL_UE_NGAP_ID: u8 = 14u8;
    pub const INCONSISTENT_REMOTE_UE_NGAP_ID: u8 = 15u8;
    pub const HANDOVER_DESIRABLE_FOR_RADIO_REASON: u8 = 16u8;
    pub const TIME_CRITICAL_HANDOVER: u8 = 17u8;
    pub const RESOURCE_OPTIMISATION_HANDOVER: u8 = 18u8;
    pub const REDUCE_LOAD_IN_SERVING_CELL: u8 = 19u8;
    pub const USER_INACTIVITY: u8 = 20u8;
    pub const RADIO_CONNECTION_WITH_UE_LOST: u8 = 21u8;
    pub const RADIO_RESOURCES_NOT_AVAILABLE: u8 = 22u8;
    pub const INVALID_QOS_COMBINATION: u8 = 23u8;
    pub const FAILURE_IN_RADIO_INTERFACE_PROCEDURE: u8 = 24u8;
    pub const INTERACTION_WITH_OTHER_PROCEDURE: u8 = 25u8;
    pub const UNKNOWN_PDU_SESSION_ID: u8 = 26u8;
    pub const UNKOWN_QOS_FLOW_ID: u8 = 27u8;
    pub const MULTIPLE_PDU_SESSION_ID_INSTANCES: u8 = 28u8;
    pub const MULTIPLE_QOS_FLOW_ID_INSTANCES: u8 = 29u8;
    pub const ENCRYPTION_AND_OR_INTEGRITY_PROTECTION_ALGORITHMS_NOT_SUPPORTED: u8 = 30u8;
    pub const NG_INTRA_SYSTEM_HANDOVER_TRIGGERED: u8 = 31u8;
    pub const NG_INTER_SYSTEM_HANDOVER_TRIGGERED: u8 = 32u8;
    pub const XN_HANDOVER_TRIGGERED: u8 = 33u8;
    pub const NOT_SUPPORTED_5QI_VALUE: u8 = 34u8;
    pub const UE_CONTEXT_TRANSFER: u8 = 35u8;
    pub const IMS_VOICE_EPS_FALLBACK_OR_RAT_FALLBACK_TRIGGERED: u8 = 36u8;
    pub const UP_INTEGRITY_PROTECTION_NOT_POSSIBLE: u8 = 37u8;
    pub const UP_CONFIDENTIALITY_PROTECTION_NOT_POSSIBLE: u8 = 38u8;
    pub const SLICE_NOT_SUPPORTED: u8 = 39u8;
    pub const UE_IN_RRC_INACTIVE_STATE_NOT_REACHABLE: u8 = 40u8;
    pub const REDIRECTION: u8 = 41u8;
    pub const RESOURCES_NOT_AVAILABLE_FOR_THE_SLICE: u8 = 42u8;
    pub const UE_MAX_INTEGRITY_PROTECTED_DATA_RATE_REASON: u8 = 43u8;
    pub const RELEASE_DUE_TO_CN_DETECTED_MOBILITY: u8 = 44u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CauseTransport(pub u8);
impl CauseTransport {
    pub const TRANSPORT_RESOURCE_UNAVAILABLE: u8 = 0u8;
    pub const UNSPECIFIED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Cell_CAGInformation {
    pub ngran_cgi: NGRAN_CGI,
    pub cell_cag_list: CellCAGList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Cell_CAGInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT_EUTRA {
    pub cell_id_listfor_mdt: CellIdListforMDT_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDT_EUTRAIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT_NR {
    pub cell_id_listfor_mdt: CellIdListforMDT_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDT_NRIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct CellCAGList(pub Vec<CAG_ID>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastEUTRA(pub Vec<CellIDBroadcastEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDBroadcastEUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDBroadcastEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastNR(pub Vec<CellIDBroadcastNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDBroadcastNR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDBroadcastNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledEUTRA(pub Vec<CellIDCancelledEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDCancelledEUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDCancelledEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledNR(pub Vec<CellIDCancelledNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIDCancelledNR_Item {
    pub nr_cgi: NR_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIDCancelledNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum CellIDListForRestart {
    #[asn(key = 0, extended = false)]
    EUTRA_CGIListforRestart(EUTRA_CGIList),
    #[asn(key = 1, extended = false)]
    NR_CGIListforRestart(NR_CGIList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(CellIDListForRestartchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT_EUTRA(pub Vec<EUTRA_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT_NR(pub Vec<NR_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CellSize(pub u8);
impl CellSize {
    pub const VERYSMALL: u8 = 0u8;
    pub const SMALL: u8 = 1u8;
    pub const MEDIUM: u8 = 2u8;
    pub const LARGE: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellTrafficTrace {
    pub protocol_i_es: CellTrafficTraceProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellType {
    pub cell_size: CellSize,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellTypeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CommonNetworkInstance(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_EUTRA(pub Vec<CompletedCellsInEAI_EUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInEAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInEAI_EUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_NR(pub Vec<CompletedCellsInEAI_NR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInEAI_NR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInEAI_NR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_EUTRA(pub Vec<CompletedCellsInTAI_EUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInTAI_EUTRA_Item {
    pub eutra_cgi: EUTRA_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInTAI_EUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_NR(pub Vec<CompletedCellsInTAI_NR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellsInTAI_NR_Item {
    pub nr_cgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellsInTAI_NR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ConcurrentWarningMessageInd(pub u8);
impl ConcurrentWarningMessageInd {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ConfidentialityProtectionIndication(pub u8);
impl ConfidentialityProtectionIndication {
    pub const REQUIRED: u8 = 0u8;
    pub const PREFERRED: u8 = 1u8;
    pub const NOT_NEEDED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ConfidentialityProtectionResult(pub u8);
impl ConfidentialityProtectionResult {
    pub const PERFORMED: u8 = 0u8;
    pub const NOT_PERFORMED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "128",
    sz_ub = "128"
)]
pub struct ConfiguredNSSAI(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ConfiguredTACIndication(pub u8);
impl ConfiguredTACIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ConnectionEstablishmentIndication {
    pub protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct CoreNetworkAssistanceInformationForInactive {
    pub ue_identity_index_value: UEIdentityIndexValue,
    #[asn(optional_idx = 0)]
    pub ue_specific_drx: Option<PagingDRX>,
    pub periodic_registration_update_timer: PeriodicRegistrationUpdateTimer,
    #[asn(optional_idx = 1)]
    pub mico_mode_indication: Option<MICOModeIndication>,
    pub tai_list_for_inactive: TAIListForInactive,
    #[asn(optional_idx = 2)]
    pub expected_ue_behaviour: Option<ExpectedUEBehaviour>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<CoreNetworkAssistanceInformationForInactiveIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct CoverageEnhancementLevel(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Criticality(pub u8);
impl Criticality {
    pub const REJECT: u8 = 0u8;
    pub const IGNORE: u8 = 1u8;
    pub const NOTIFY: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CriticalityDiagnostics {
    #[asn(optional_idx = 0)]
    pub procedure_code: Option<ProcedureCode>,
    #[asn(optional_idx = 1)]
    pub triggering_message: Option<TriggeringMessage>,
    #[asn(optional_idx = 2)]
    pub procedure_criticality: Option<Criticality>,
    #[asn(optional_idx = 3)]
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CriticalityDiagnosticsIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CriticalityDiagnostics_IE_Item {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIE_ID,
    pub type_of_error: TypeOfError,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CriticalityDiagnostics_IE_List(pub Vec<CriticalityDiagnostics_IE_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSRequestInfo {
    pub daps_indicator: ENUMERATED_14,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSRequestInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfo {
    pub dapsresponseindicator: ENUMERATED_15,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfoItem {
    pub drb_id: DRB_ID,
    pub daps_response_info: DAPSResponseInfo,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DAPSResponseInfoItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DAPSResponseInfoList(pub Vec<DAPSResponseInfoItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DL_CP_SecurityInformation {
    pub dl_nas_mac: DL_NAS_MAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct DL_NAS_MAC(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DL_NGU_TNLInformationReused(pub u8);
impl DL_NGU_TNLInformationReused {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DLForwarding(pub u8);
impl DLForwarding {
    pub const DL_FORWARDING_PROPOSED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "32", extensible = true)]
pub struct DRB_ID(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DRBStatusDL {
    #[asn(key = 0, extended = false)]
    DRBStatusDL12(DRBStatusDL12),
    #[asn(key = 1, extended = false)]
    DRBStatusDL18(DRBStatusDL18),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(DRBStatusDLchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBStatusDL12 {
    pub dl_count_value: COUNTValueForPDCP_SN12,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBStatusDL12IE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBStatusDL18 {
    pub dl_count_value: COUNTValueForPDCP_SN18,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBStatusDL18IE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum DRBStatusUL {
    #[asn(key = 0, extended = false)]
    DRBStatusUL12(DRBStatusUL12),
    #[asn(key = 1, extended = false)]
    DRBStatusUL18(DRBStatusUL18),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(DRBStatusULchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DRBStatusUL12 {
    pub ul_count_value: COUNTValueForPDCP_SN12,
    #[asn(optional_idx = 0)]
    pub receive_status_of_ul_pdcp_sd_us: Option<BIT_STRING_16>,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<DRBStatusUL12IE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct DRBStatusUL18 {
    pub ul_count_value: COUNTValueForPDCP_SN18,
    #[asn(optional_idx = 0)]
    pub receive_status_of_ul_pdcp_sd_us: Option<BIT_STRING_17>,
    #[asn(optional_idx = 1)]
    pub ie_extension: Option<DRBStatusUL18IE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsSubjectToEarlyStatusTransfer_Item {
    pub drb_id: DRB_ID,
    pub first_dlcount: DRBStatusDL,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsSubjectToEarlyStatusTransfer_List(pub Vec<DRBsSubjectToEarlyStatusTransfer_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsSubjectToStatusTransferItem {
    pub drb_id: DRB_ID,
    pub drb_status_ul: DRBStatusUL,
    pub drb_status_dl: DRBStatusDL,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<DRBsSubjectToStatusTransferItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsSubjectToStatusTransferList(pub Vec<DRBsSubjectToStatusTransferItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DRBsToQosFlowsMappingItem {
    pub drb_id: DRB_ID,
    pub associated_qos_flow_list: AssociatedQosFlowList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DRBsToQosFlowsMappingItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DRBsToQosFlowsMappingList(pub Vec<DRBsToQosFlowsMappingItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct DataCodingScheme(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DataForwardingAccepted(pub u8);
impl DataForwardingAccepted {
    pub const DATA_FORWARDING_ACCEPTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DataForwardingNotPossible(pub u8);
impl DataForwardingNotPossible {
    pub const DATA_FORWARDING_NOT_POSSIBLE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct DataForwardingResponseDRBItem {
    pub drb_id: DRB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ul_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<DataForwardingResponseDRBItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct DataForwardingResponseDRBList(pub Vec<DataForwardingResponseDRBItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct DataForwardingResponseERABList(pub Vec<DataForwardingResponseERABListItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DataForwardingResponseERABListItem {
    pub e_rab_id: E_RAB_ID,
    pub dl_forwarding_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DataForwardingResponseERABListItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeactivateTrace {
    pub protocol_i_es: DeactivateTraceProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DelayCritical(pub u8);
impl DelayCritical {
    pub const DELAY_CRITICAL: u8 = 0u8;
    pub const NON_DELAY_CRITICAL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DirectForwardingPathAvailability(pub u8);
impl DirectForwardingPathAvailability {
    pub const DIRECT_PATH_AVAILABLE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNASTransport {
    pub protocol_i_es: DownlinkNASTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNonUEAssociatedNRPPaTransport {
    pub protocol_i_es: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANConfigurationTransfer {
    pub protocol_i_es: DownlinkRANConfigurationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANEarlyStatusTransfer {
    pub protocol_i_es: DownlinkRANEarlyStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRANStatusTransfer {
    pub protocol_i_es: DownlinkRANStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkRIMInformationTransfer {
    pub protocol_i_es: DownlinkRIMInformationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkUEAssociatedNRPPaTransport {
    pub protocol_i_es: DownlinkUEAssociatedNRPPaTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct Dynamic5QIDescriptor {
    pub priority_level_qos: PriorityLevelQos,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    #[asn(optional_idx = 0)]
    pub five_qi: Option<FiveQI>,
    #[asn(optional_idx = 1)]
    pub delay_critical: Option<DelayCritical>,
    #[asn(optional_idx = 2)]
    pub averaging_window: Option<AveragingWindow>,
    #[asn(optional_idx = 3)]
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<Dynamic5QIDescriptorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct E_RAB_ID(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABInformationItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DLForwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABInformationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABInformationList(pub Vec<E_RABInformationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EDT_Session(pub u8);
impl EDT_Session {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct EN_DCSONConfigurationTransfer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum ENB_ID {
    #[asn(key = 0, extended = false)]
    MacroENB_ID(BIT_STRING_18),
    #[asn(key = 1, extended = false)]
    HomeENB_ID(BIT_STRING_19),
    #[asn(key = 2, extended = false)]
    Short_macroENB_ID(BIT_STRING_20),
    #[asn(key = 3, extended = false)]
    Long_macroENB_ID(BIT_STRING_21),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(ENB_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct EPS_TAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EPS_TAI {
    pub plmn_identity: PLMNIdentity,
    pub eps_tac: EPS_TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EPS_TAIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EUTRA_CGI {
    pub plmn_identity: PLMNIdentity,
    pub eutra_cell_identity: EUTRACellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EUTRA_CGIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EUTRA_CGIList(pub Vec<EUTRA_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRA_CGIListForWarning(pub Vec<EUTRA_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct EUTRACellIdentity(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EUTRAencryptionAlgorithms(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EUTRAintegrityProtectionAlgorithms(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EarlyStatusTransfer_TransparentContainer {
    pub procedure_stage: ProcedureStageChoice,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EarlyStatusTransfer_TransparentContainerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct EmergencyAreaID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastEUTRA(pub Vec<EmergencyAreaIDBroadcastEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDBroadcastEUTRA_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cells_in_eai_eutra: CompletedCellsInEAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastNR(pub Vec<EmergencyAreaIDBroadcastNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDBroadcastNR_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cells_in_eai_nr: CompletedCellsInEAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDBroadcastNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledEUTRA(pub Vec<EmergencyAreaIDCancelledEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDCancelledEUTRA_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cells_in_eai_eutra: CancelledCellsInEAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledNR(pub Vec<EmergencyAreaIDCancelledNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaIDCancelledNR_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cells_in_eai_nr: CancelledCellsInEAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaIDCancelledNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDList(pub Vec<EmergencyAreaID>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EmergencyAreaIDListForRestart(pub Vec<EmergencyAreaID>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EmergencyFallbackIndicator {
    pub emergency_fallback_request_indicator: EmergencyFallbackRequestIndicator,
    #[asn(optional_idx = 0)]
    pub emergency_service_target_cn: Option<EmergencyServiceTargetCN>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<EmergencyFallbackIndicatorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EmergencyFallbackRequestIndicator(pub u8);
impl EmergencyFallbackRequestIndicator {
    pub const EMERGENCY_FALLBACK_REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EmergencyServiceTargetCN(pub u8);
impl EmergencyServiceTargetCN {
    pub const FIVE_GC: u8 = 0u8;
    pub const EPC: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EndIndication(pub u8);
impl EndIndication {
    pub const NO_FURTHER_DATA: u8 = 0u8;
    pub const FURTHER_DATA_EXISTS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct EndpointIPAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EndpointIPAddressAndPortIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Enhanced_CoverageRestriction(pub u8);
impl Enhanced_CoverageRestriction {
    pub const RESTRICTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct EquivalentPLMNs(pub Vec<PLMNIdentity>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ErrorIndication {
    pub protocol_i_es: ErrorIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EventL1LoggedMDTConfig {
    pub l1_threshold: MeasurementThresholdL1LoggedMDT,
    pub hysteresis: Hysteresis,
    pub time_to_trigger: TimeToTrigger,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EventL1LoggedMDTConfigIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum EventTrigger {
    #[asn(key = 0, extended = false)]
    OutOfCoverage(ENUMERATED_22),
    #[asn(key = 1, extended = false)]
    EventL1LoggedMDTConfig(EventL1LoggedMDTConfig),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(EventTriggerchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct EventType(pub u8);
impl EventType {
    pub const DIRECT: u8 = 0u8;
    pub const CHANGE_OF_SERVE_CELL: u8 = 1u8;
    pub const UE_PRESENCE_IN_AREA_OF_INTEREST: u8 = 2u8;
    pub const STOP_CHANGE_OF_SERVE_CELL: u8 = 3u8;
    pub const STOP_UE_PRESENCE_IN_AREA_OF_INTEREST: u8 = 4u8;
    pub const CANCEL_LOCATION_REPORTING_FOR_THE_UE: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedActivityPeriod(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct ExpectedHOInterval(pub u8);
impl ExpectedHOInterval {
    pub const SEC15: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC90: u8 = 3u8;
    pub const SEC120: u8 = 4u8;
    pub const SEC180: u8 = 5u8;
    pub const LONG_TIME: u8 = 6u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedIdlePeriod(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ExpectedUEActivityBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    #[asn(optional_idx = 1)]
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    #[asn(optional_idx = 2)]
    pub source_of_ue_activity_behaviour_information: Option<SourceOfUEActivityBehaviourInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct ExpectedUEBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_ue_activity_behaviour: Option<ExpectedUEActivityBehaviour>,
    #[asn(optional_idx = 1)]
    pub expected_ho_interval: Option<ExpectedHOInterval>,
    #[asn(optional_idx = 2)]
    pub expected_ue_mobility: Option<ExpectedUEMobility>,
    #[asn(optional_idx = 3)]
    pub expected_ue_moving_trajectory: Option<ExpectedUEMovingTrajectory>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<ExpectedUEBehaviourIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ExpectedUEMobility(pub u8);
impl ExpectedUEMobility {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ExpectedUEMovingTrajectory(pub Vec<ExpectedUEMovingTrajectoryItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ExpectedUEMovingTrajectoryItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<INTEGER_23>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ExpectedUEMovingTrajectoryItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct Extended_AMFName {
    #[asn(optional_idx = 0)]
    pub amf_name_visible_string: Option<AMFNameVisibleString>,
    #[asn(optional_idx = 1)]
    pub amf_name_utf8_string: Option<AMFNameUTF8String>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<Extended_AMFNameIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct Extended_ConnectedTime(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct Extended_RANNodeName {
    #[asn(optional_idx = 0)]
    pub ran_node_name_visible_string: Option<RANNodeNameVisibleString>,
    #[asn(optional_idx = 1)]
    pub ran_node_name_utf8_string: Option<RANNodeNameUTF8String>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<Extended_RANNodeNameIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "65535", extensible = true)]
pub struct ExtendedPacketDelayBudget(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ExtendedRATRestrictionInformation {
    pub primary_rat_restriction: BIT_STRING_24,
    pub secondary_rat_restriction: BIT_STRING_25,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ExtendedRATRestrictionInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "4096", ub = "65535")]
pub struct ExtendedRNC_ID(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExtendedSliceSupportList(pub Vec<SliceSupportItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct ExtendedUEIdentityIndexValue(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FailureIndication {
    pub uerlf_report_container: UERLFReportContainer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FailureIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FirstDLCount {
    pub dr_bs_subject_to_early_status_transfer: DRBsSubjectToEarlyStatusTransfer_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<FirstDLCountIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FiveG_S_TMSI {
    pub amf_set_id: AMFSetID,
    pub amf_pointer: AMFPointer,
    pub five_g_tmsi: FiveG_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FiveG_S_TMSIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct FiveG_TMSI(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct FiveQI(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenAreaInformation(pub Vec<ForbiddenAreaInformation_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenAreaInformation_Item {
    pub plmn_identity: PLMNIdentity,
    pub forbidden_ta_cs: ForbiddenTACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenAreaInformation_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenTACs(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FromEUTRANtoNGRAN {
    pub sourcee_nbid: IntersystemSONeNBID,
    pub target_ngra_nnode_id: IntersystemSONNGRANnodeID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FromEUTRANtoNGRANIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct FromNGRANtoEUTRAN {
    pub source_ngra_nnode_id: IntersystemSONNGRANnodeID,
    pub targete_nbid: IntersystemSONeNBID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FromNGRANtoEUTRANIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct GBR_QosInformation {
    pub maximum_flow_bit_rate_dl: BitRate,
    pub maximum_flow_bit_rate_ul: BitRate,
    pub guaranteed_flow_bit_rate_dl: BitRate,
    pub guaranteed_flow_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub notification_control: Option<NotificationControl>,
    #[asn(optional_idx = 1)]
    pub maximum_packet_loss_rate_dl: Option<PacketLossRate>,
    #[asn(optional_idx = 2)]
    pub maximum_packet_loss_rate_ul: Option<PacketLossRate>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<GBR_QosInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum GNB_ID {
    #[asn(key = 0, extended = false)]
    GNB_ID(BIT_STRING_26),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(GNB_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "22")]
pub struct GNBSetID(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct GTP_TEID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GTPTunnel {
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GTPTunnelIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GUAMI {
    pub plmn_identity: PLMNIdentity,
    pub amf_region_id: AMFRegionID,
    pub amf_set_id: AMFSetID,
    pub amf_pointer: AMFPointer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GUAMIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct GUAMIType(pub u8);
impl GUAMIType {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct GlobalCable_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalENB_ID {
    pub plm_nidentity: PLMNIdentity,
    pub enb_id: ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalENB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalGNB_ID {
    pub plmn_identity: PLMNIdentity,
    pub gnb_id: GNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalGNB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct GlobalLine_ID {
    pub global_line_identity: GlobalLineIdentity,
    #[asn(optional_idx = 0)]
    pub line_type: Option<LineType>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<GlobalLine_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct GlobalLineIdentity(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalN3IWF_ID {
    pub plmn_identity: PLMNIdentity,
    pub n3iwf_id: N3IWF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalN3IWF_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalNgENB_ID {
    pub plmn_identity: PLMNIdentity,
    pub ng_enb_id: NgENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalNgENB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum GlobalRANNodeID {
    #[asn(key = 0, extended = false)]
    GlobalGNB_ID(GlobalGNB_ID),
    #[asn(key = 1, extended = false)]
    GlobalNgENB_ID(GlobalNgENB_ID),
    #[asn(key = 2, extended = false)]
    GlobalN3IWF_ID(GlobalN3IWF_ID),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(GlobalRANNodeIDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalTNGF_ID {
    pub plmn_identity: PLMNIdentity,
    pub tngf_id: TNGF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalTNGF_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalTWIF_ID {
    pub plmn_identity: PLMNIdentity,
    pub twif_id: TWIF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalTWIF_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GlobalW_AGF_ID {
    pub plmn_identity: PLMNIdentity,
    pub w_agf_id: W_AGF_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GlobalW_AGF_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct HFCNode_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct HOReport {
    pub handover_report_type: ENUMERATED_27,
    pub handover_cause: Cause,
    pub sourcecell_cgi: NGRAN_CGI,
    pub targetcell_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub reestablishmentcell_cgi: Option<NGRAN_CGI>,
    #[asn(optional_idx = 1)]
    pub sourcecell_c_rnti: Option<BIT_STRING_28>,
    #[asn(optional_idx = 2)]
    pub targetcellin_e_utran: Option<EUTRA_CGI>,
    #[asn(optional_idx = 3)]
    pub mobility_information: Option<MobilityInformation>,
    #[asn(optional_idx = 4)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<HOReportIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancel {
    pub protocol_i_es: HandoverCancelProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancelAcknowledge {
    pub protocol_i_es: HandoverCancelAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCommand {
    pub protocol_i_es: HandoverCommandProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct HandoverCommandTransfer {
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub qos_flow_to_be_forwarded_list: Option<QosFlowToBeForwardedList>,
    #[asn(optional_idx = 2)]
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<HandoverCommandTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverFailure {
    pub protocol_i_es: HandoverFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HandoverFlag(pub u8);
impl HandoverFlag {
    pub const HANDOVER_PREPARATION: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverNotify {
    pub protocol_i_es: HandoverNotifyProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverPreparationFailure {
    pub protocol_i_es: HandoverPreparationFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct HandoverPreparationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<HandoverPreparationUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequest {
    pub protocol_i_es: HandoverRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequestAcknowledge {
    pub protocol_i_es: HandoverRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct HandoverRequestAcknowledgeTransfer {
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub dl_forwarding_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub security_result: Option<SecurityResult>,
    pub qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    #[asn(optional_idx = 2)]
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 3)]
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDRBList>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<HandoverRequestAcknowledgeTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequired {
    pub protocol_i_es: HandoverRequiredProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct HandoverRequiredTransfer {
    #[asn(optional_idx = 0)]
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<HandoverRequiredTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct HandoverResourceAllocationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<HandoverResourceAllocationUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverSuccess {
    pub protocol_i_es: HandoverSuccessProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct HandoverType(pub u8);
impl HandoverType {
    pub const INTRA5GS: u8 = 0u8;
    pub const FIVEGS_TO_EPS: u8 = 1u8;
    pub const EPS_TO_5GS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "30")]
pub struct Hysteresis(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IAB_Authorized(pub u8);
impl IAB_Authorized {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Supported(pub u8);
impl IAB_Supported {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IABNodeIndication(pub u8);
impl IABNodeIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IMSVoiceSupportIndicator(pub u8);
impl IMSVoiceSupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
    pub const NOT_SUPPORTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 10)]
pub struct ImmediateMDTNr {
    pub measurements_to_activate: MeasurementsToActivate,
    #[asn(optional_idx = 0)]
    pub m1_configuration: Option<M1Configuration>,
    #[asn(optional_idx = 1)]
    pub m4_configuration: Option<M4Configuration>,
    #[asn(optional_idx = 2)]
    pub m5_configuration: Option<M5Configuration>,
    #[asn(optional_idx = 3)]
    pub m6_configuration: Option<M6Configuration>,
    #[asn(optional_idx = 4)]
    pub m7_configuration: Option<M7Configuration>,
    #[asn(optional_idx = 5)]
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    #[asn(optional_idx = 6)]
    pub wlan_measurement_configuration: Option<WLANMeasurementConfiguration>,
    #[asn(optional_idx = 7)]
    pub mdt_location_info: Option<MDT_Location_Info>,
    #[asn(optional_idx = 8)]
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
    #[asn(optional_idx = 9)]
    pub ie_extensions: Option<ImmediateMDTNrIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256", extensible = true)]
pub struct IndexToRFSP(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InfoOnRecommendedCellsAndRANNodesForPaging {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    pub recommend_ran_nodes_for_paging: RecommendedRANNodesForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupFailure {
    pub protocol_i_es: InitialContextSetupFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupRequest {
    pub protocol_i_es: InitialContextSetupRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupResponse {
    pub protocol_i_es: InitialContextSetupResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialUEMessage {
    pub protocol_i_es: InitialUEMessageProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingMessage {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: InitiatingMessageValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct IntegrityProtectionIndication(pub u8);
impl IntegrityProtectionIndication {
    pub const REQUIRED: u8 = 0u8;
    pub const PREFERRED: u8 = 1u8;
    pub const NOT_NEEDED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IntegrityProtectionResult(pub u8);
impl IntegrityProtectionResult {
    pub const PERFORMED: u8 = 0u8;
    pub const NOT_PERFORMED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct IntendedNumberOfPagingAttempts(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct InterSystemFailureIndication {
    #[asn(optional_idx = 0)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<InterSystemFailureIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InterSystemHOReport {
    pub handover_report_type: InterSystemHandoverReportType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InterSystemHOReportIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum InterSystemHandoverReportType {
    #[asn(key = 0, extended = false)]
    TooearlyIntersystemHO(TooearlyIntersystemHO),
    #[asn(key = 1, extended = false)]
    IntersystemUnnecessaryHO(IntersystemUnnecessaryHO),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(InterSystemHandoverReportTypechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct InterfacesToTrace(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONConfigurationTransfer {
    pub transfer_type: IntersystemSONTransferType,
    pub intersystem_son_information: IntersystemSONInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONConfigurationTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum IntersystemSONInformation {
    #[asn(key = 0, extended = false)]
    IntersystemSONInformationReport(IntersystemSONInformationReport),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(IntersystemSONInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum IntersystemSONInformationReport {
    #[asn(key = 0, extended = false)]
    HOReportInformation(InterSystemHOReport),
    #[asn(key = 1, extended = false)]
    FailureIndicationInformation(InterSystemFailureIndication),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(IntersystemSONInformationReportchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONNGRANnodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONNGRANnodeIDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum IntersystemSONTransferType {
    #[asn(key = 0, extended = false)]
    FromEUTRANtoNGRAN(FromEUTRANtoNGRAN),
    #[asn(key = 1, extended = false)]
    FromNGRANtoEUTRAN(FromNGRANtoEUTRAN),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(IntersystemSONTransferTypechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemSONeNBID {
    pub globale_nbid: GlobalENB_ID,
    pub selected_epstai: EPS_TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemSONeNBIDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct IntersystemUnnecessaryHO {
    pub sourcecell_id: NGRAN_CGI,
    pub targetcell_id: EUTRA_CGI,
    pub early_iratho: ENUMERATED_29,
    pub candidate_cell_list: CandidateCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<IntersystemUnnecessaryHOIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LAI {
    pub plm_nidentity: PLMNIdentity,
    pub lac: LAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LAIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LTEM_Indication(pub u8);
impl LTEM_Indication {
    pub const LTE_M: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LTEUERLFReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LTEUESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LTEUESidelinkAggregateMaximumBitrateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LTEV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LTEV2XServicesAuthorizedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum LastVisitedCellInformation {
    #[asn(key = 0, extended = false)]
    NGRANCell(LastVisitedNGRANCellInformation),
    #[asn(key = 1, extended = false)]
    EUTRANCell(LastVisitedEUTRANCellInformation),
    #[asn(key = 2, extended = false)]
    UTRANCell(LastVisitedUTRANCellInformation),
    #[asn(key = 3, extended = false)]
    GERANCell(LastVisitedGERANCellInformation),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(LastVisitedCellInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LastVisitedCellItem {
    pub last_visited_cell_information: LastVisitedCellInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LastVisitedCellItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedEUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedGERANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LastVisitedNGRANCellInformation {
    pub global_cell_id: NGRAN_CGI,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: TimeUEStayedInCell,
    #[asn(optional_idx = 0)]
    pub time_ue_stayed_in_cell_enhanced_granularity: Option<TimeUEStayedInCellEnhancedGranularity>,
    #[asn(optional_idx = 1)]
    pub ho_cause_value: Option<Cause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LastVisitedNGRANCellInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedUTRANCellInformation(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct LineType(pub u8);
impl LineType {
    pub const DSL: u8 = 0u8;
    pub const PON: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Links_to_log(pub u8);
impl Links_to_log {
    pub const UPLINK: u8 = 0u8;
    pub const DOWNLINK: u8 = 1u8;
    pub const BOTH_UPLINK_AND_DOWNLINK: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReport {
    pub protocol_i_es: LocationReportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LocationReportingAdditionalInfo(pub u8);
impl LocationReportingAdditionalInfo {
    pub const INCLUDE_PS_CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingControl {
    pub protocol_i_es: LocationReportingControlProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingFailureIndication {
    pub protocol_i_es: LocationReportingFailureIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "64", extensible = true)]
pub struct LocationReportingReferenceID(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct LocationReportingRequestType {
    pub event_type: EventType,
    pub report_area: ReportArea,
    #[asn(optional_idx = 0)]
    pub area_of_interest_list: Option<AreaOfInterestList>,
    #[asn(optional_idx = 1)]
    pub location_reporting_reference_id_to_be_cancelled: Option<LocationReportingReferenceID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<LocationReportingRequestTypeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct LoggedMDTNr {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    pub logged_mdt_trigger: LoggedMDTTrigger,
    #[asn(optional_idx = 0)]
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    #[asn(optional_idx = 1)]
    pub wlan_measurement_configuration: Option<WLANMeasurementConfiguration>,
    #[asn(optional_idx = 2)]
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
    #[asn(optional_idx = 3)]
    pub area_scope_of_neigh_cells_list: Option<AreaScopeOfNeighCellsList>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<LoggedMDTNrIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum LoggedMDTTrigger {
    #[asn(key = 0, extended = false)]
    Periodical(NULL_30),
    #[asn(key = 1, extended = false)]
    EventTrigger(EventTrigger),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(LoggedMDTTriggerchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct LoggingDuration(pub u8);
impl LoggingDuration {
    pub const M10: u8 = 0u8;
    pub const M20: u8 = 1u8;
    pub const M40: u8 = 2u8;
    pub const M60: u8 = 3u8;
    pub const M90: u8 = 4u8;
    pub const M120: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "10")]
pub struct LoggingInterval(pub u8);
impl LoggingInterval {
    pub const MS320: u8 = 0u8;
    pub const MS640: u8 = 1u8;
    pub const MS1280: u8 = 2u8;
    pub const MS2560: u8 = 3u8;
    pub const MS5120: u8 = 4u8;
    pub const MS10240: u8 = 5u8;
    pub const MS20480: u8 = 6u8;
    pub const MS30720: u8 = 7u8;
    pub const MS40960: u8 = 8u8;
    pub const MS61440: u8 = 9u8;
    pub const INFINITY: u8 = 10u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct M1Configuration {
    pub m1reporting_trigger: M1ReportingTrigger,
    #[asn(optional_idx = 0)]
    pub m1threshold_event_a2: Option<M1ThresholdEventA2>,
    #[asn(optional_idx = 1)]
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<M1ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMDT,
    pub report_amount: ReportAmountMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1PeriodicReportingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct M1ReportingTrigger(pub u8);
impl M1ReportingTrigger {
    pub const PERIODIC: u8 = 0u8;
    pub const A2EVENTTRIGGERED: u8 = 1u8;
    pub const A2EVENTTRIGGERED_PERIODIC: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1ThresholdEventA2 {
    pub m1_threshold_type: M1ThresholdType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1ThresholdEventA2IE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum M1ThresholdType {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
    #[asn(key = 2, extended = false)]
    Threshold_SINR(Threshold_SINR),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(M1ThresholdTypechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M4ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M4period(pub u8);
impl M4period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M5ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M5period(pub u8);
impl M5period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M6Configuration {
    pub m6report_interval: M6report_Interval,
    pub m6_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M6ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct M6report_Interval(pub u8);
impl M6report_Interval {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MS20480: u8 = 8u8;
    pub const MS40960: u8 = 9u8;
    pub const MIN1: u8 = 10u8;
    pub const MIN6: u8 = 11u8;
    pub const MIN12: u8 = 12u8;
    pub const MIN30: u8 = 13u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M7ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "60", extensible = true)]
pub struct M7period(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct MDT_Activation(pub u8);
impl MDT_Activation {
    pub const IMMEDIATE_MDT_ONLY: u8 = 0u8;
    pub const LOGGED_MDT_ONLY: u8 = 1u8;
    pub const IMMEDIATE_MDT_AND_TRACE: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct MDT_Configuration {
    #[asn(optional_idx = 0)]
    pub mdt_config_nr: Option<MDT_Configuration_NR>,
    #[asn(optional_idx = 1)]
    pub mdt_config_eutra: Option<MDT_Configuration_EUTRA>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<MDT_ConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MDT_Configuration_EUTRA {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT_EUTRA,
    pub mdt_mode: MDTModeEutra,
    #[asn(optional_idx = 0)]
    pub signalling_based_mdtplmn_list: Option<MDTPLMNList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MDT_Configuration_EUTRAIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MDT_Configuration_NR {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT_NR,
    pub mdt_mode_nr: MDTModeNr,
    #[asn(optional_idx = 0)]
    pub signalling_based_mdtplmn_list: Option<MDTPLMNList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MDT_Configuration_NRIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MDT_Location_Info {
    pub mdt_location_information: MDT_Location_Information,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MDT_Location_InfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MDT_Location_Information(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct MDTModeEutra(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum MDTModeNr {
    #[asn(key = 0, extended = false)]
    ImmediateMDTNr(ImmediateMDTNr),
    #[asn(key = 1, extended = false)]
    LoggedMDTNr(LoggedMDTNr),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(MDTModeNrchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MDTPLMNList(pub Vec<PLMNIdentity>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MICOModeIndication(pub u8);
impl MICOModeIndication {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct MaskedIMEISV(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095", extensible = true)]
pub struct MaximumDataBurstVolume(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct MaximumIntegrityProtectedDataRate(pub u8);
impl MaximumIntegrityProtectedDataRate {
    pub const BITRATE64KBS: u8 = 0u8;
    pub const MAXIMUM_UE_RATE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum MeasurementThresholdL1LoggedMDT {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(MeasurementThresholdL1LoggedMDTchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasurementsToActivate(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MessageIdentifier(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MobilityInformation(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct MobilityRestrictionList {
    pub serving_plmn: PLMNIdentity,
    #[asn(optional_idx = 0)]
    pub equivalent_plm_ns: Option<EquivalentPLMNs>,
    #[asn(optional_idx = 1)]
    pub rat_restrictions: Option<RATRestrictions>,
    #[asn(optional_idx = 2)]
    pub forbidden_area_information: Option<ForbiddenAreaInformation>,
    #[asn(optional_idx = 3)]
    pub service_area_information: Option<ServiceAreaInformation>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<MobilityRestrictionListIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum N3IWF_ID {
    #[asn(key = 0, extended = false)]
    N3IWF_ID(BIT_STRING_31),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(N3IWF_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NAS_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASNonDeliveryIndication {
    pub protocol_i_es: NASNonDeliveryIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParametersFromNGRAN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct NB_IoT_DefaultPagingDRX(pub u8);
impl NB_IoT_DefaultPagingDRX {
    pub const RF128: u8 = 0u8;
    pub const RF256: u8 = 1u8;
    pub const RF512: u8 = 2u8;
    pub const RF1024: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct NB_IoT_Paging_TimeWindow(pub u8);
impl NB_IoT_Paging_TimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct NB_IoT_Paging_eDRXCycle(pub u8);
impl NB_IoT_Paging_eDRXCycle {
    pub const HF2: u8 = 0u8;
    pub const HF4: u8 = 1u8;
    pub const HF6: u8 = 2u8;
    pub const HF8: u8 = 3u8;
    pub const HF10: u8 = 4u8;
    pub const HF12: u8 = 5u8;
    pub const HF14: u8 = 6u8;
    pub const HF16: u8 = 7u8;
    pub const HF32: u8 = 8u8;
    pub const HF64: u8 = 9u8;
    pub const HF128: u8 = 10u8;
    pub const HF256: u8 = 11u8;
    pub const HF512: u8 = 12u8;
    pub const HF1024: u8 = 13u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NB_IoT_Paging_eDRXInfo {
    pub nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRXCycle,
    #[asn(optional_idx = 0)]
    pub nb_io_t_paging_time_window: Option<NB_IoT_Paging_TimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NB_IoT_Paging_eDRXInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct NB_IoT_PagingDRX(pub u8);
impl NB_IoT_PagingDRX {
    pub const RF32: u8 = 0u8;
    pub const RF64: u8 = 1u8;
    pub const RF128: u8 = 2u8;
    pub const RF256: u8 = 3u8;
    pub const RF512: u8 = 4u8;
    pub const RF1024: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct NB_IoT_UEPriority(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum NGAP_PDU {
    #[asn(key = 0, extended = false)]
    InitiatingMessage(InitiatingMessage),
    #[asn(key = 1, extended = false)]
    SuccessfulOutcome(SuccessfulOutcome),
    #[asn(key = 2, extended = false)]
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum NGRAN_CGI {
    #[asn(key = 0, extended = false)]
    NR_CGI(NR_CGI),
    #[asn(key = 1, extended = false)]
    EUTRA_CGI(EUTRA_CGI),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(NGRAN_CGIchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct NGRAN_TNLAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub tnl_association_transport_layer_address_amf: Option<CPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NGRAN_TNLAssociationToRemoveItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct NGRAN_TNLAssociationToRemoveList(pub Vec<NGRAN_TNLAssociationToRemoveItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct NGRANTraceID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGReset {
    pub protocol_i_es: NGResetProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGResetAcknowledge {
    pub protocol_i_es: NGResetAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupFailure {
    pub protocol_i_es: NGSetupFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupRequest {
    pub protocol_i_es: NGSetupRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NGSetupResponse {
    pub protocol_i_es: NGSetupResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "44", sz_ub = "44")]
pub struct NID(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_AccessInformation {
    #[asn(key = 0, extended = false)]
    PNI_NPN_Access_Information(CellCAGList),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_AccessInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum NPN_MobilityInformation {
    #[asn(key = 0, extended = false)]
    SNPN_MobilityInformation(SNPN_MobilityInformation),
    #[asn(key = 1, extended = false)]
    PNI_NPN_MobilityInformation(PNI_NPN_MobilityInformation),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(NPN_MobilityInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_PagingAssistanceInformation {
    #[asn(key = 0, extended = false)]
    PNI_NPN_PagingAssistance(Allowed_PNI_NPN_List),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_PagingAssistanceInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum NPN_Support {
    #[asn(key = 0, extended = false)]
    SNPN(NID),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(NPN_Supportchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NR_CGI {
    pub plmn_identity: PLMNIdentity,
    pub nr_cell_identity: NRCellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NR_CGIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct NR_CGIList(pub Vec<NR_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIListForWarning(pub Vec<NR_CGI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007", extensible = true)]
pub struct NR_PCI(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct NRARFCN(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct NRCellIdentity(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1024", extensible = true)]
pub struct NRFrequencyBand(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct NRFrequencyBand_List(pub Vec<NRFrequencyBandItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRFrequencyBandItem {
    pub nr_frequency_band: NRFrequencyBand,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<NRFrequencyBandItemIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRFrequencyInfo {
    pub nr_arfcn: NRARFCN,
    pub frequency_band_list: NRFrequencyBand_List,
    #[asn(optional_idx = 0)]
    pub ie_extension: Option<NRFrequencyInfoIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRMobilityHistoryReport(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRPPa_PDU(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct NRUERLFReportContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRencryptionAlgorithms(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRintegrityProtectionAlgorithms(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256", extensible = true)]
pub struct NetworkInstance(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NewSecurityContextInd(pub u8);
impl NewSecurityContextInd {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct NextHopChainingCount(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NextPagingAreaScope(pub u8);
impl NextPagingAreaScope {
    pub const SAME: u8 = 0u8;
    pub const CHANGED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum NgENB_ID {
    #[asn(key = 0, extended = false)]
    MacroNgENB_ID(BIT_STRING_32),
    #[asn(key = 1, extended = false)]
    ShortMacroNgENB_ID(BIT_STRING_33),
    #[asn(key = 2, extended = false)]
    LongMacroNgENB_ID(BIT_STRING_34),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(NgENB_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct NonDynamic5QIDescriptor {
    pub five_qi: FiveQI,
    #[asn(optional_idx = 0)]
    pub priority_level_qos: Option<PriorityLevelQos>,
    #[asn(optional_idx = 1)]
    pub averaging_window: Option<AveragingWindow>,
    #[asn(optional_idx = 2)]
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<NonDynamic5QIDescriptorIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct NotAllowedTACs(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NotificationCause(pub u8);
impl NotificationCause {
    pub const FULFILLED: u8 = 0u8;
    pub const NOT_FULFILLED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotificationControl(pub u8);
impl NotificationControl {
    pub const NOTIFICATION_REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotifySourceNGRANNode(pub u8);
impl NotifySourceNGRANNode {
    pub const NOTIFY_SOURCE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcasts(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcastsRequested(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct OverloadAction(pub u8);
impl OverloadAction {
    pub const REJECT_NON_EMERGENCY_MO_DT: u8 = 0u8;
    pub const REJECT_RRC_CR_SIGNALLING: u8 = 1u8;
    pub const PERMIT_EMERGENCY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 2u8;
    pub const PERMIT_HIGH_PRIORITY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum OverloadResponse {
    #[asn(key = 0, extended = false)]
    OverloadAction(OverloadAction),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(OverloadResponsechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStart {
    pub protocol_i_es: OverloadStartProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct OverloadStartNSSAIItem {
    pub slice_overload_list: SliceOverloadList,
    #[asn(optional_idx = 0)]
    pub slice_overload_response: Option<OverloadResponse>,
    #[asn(optional_idx = 1)]
    pub slice_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<OverloadStartNSSAIItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct OverloadStartNSSAIList(pub Vec<OverloadStartNSSAIItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStop {
    pub protocol_i_es: OverloadStopProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PC5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PC5FlowBitRatesIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PC5QoSFlowItem {
    pub pqi: FiveQI,
    #[asn(optional_idx = 0)]
    pub pc5_flow_bit_rates: Option<PC5FlowBitRates>,
    #[asn(optional_idx = 1)]
    pub range: Option<Range>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PC5QoSFlowItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct PC5QoSFlowList(pub Vec<PC5QoSFlowItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PC5QoSParameters {
    pub pc5_qo_s_flow_list: PC5QoSFlowList,
    #[asn(optional_idx = 0)]
    pub pc5_link_aggregate_bit_rates: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PC5QoSParametersIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct PCIListForMDT(pub Vec<NR_PCI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionAggregateMaximumBitRate {
    pub pdu_session_aggregate_maximum_bit_rate_dl: BitRate,
    pub pdu_session_aggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionAggregateMaximumBitRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct PDUSessionID(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceAdmittedItem {
    pub pdu_session_id: PDUSessionID,
    pub handover_request_acknowledge_transfer: OCTET_STRING_35,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceAdmittedItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceAdmittedList(pub Vec<PDUSessionResourceAdmittedItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToModifyItemModCfm {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_indication_unsuccessful_transfer: OCTET_STRING_36,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToModifyItemModCfmIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToModifyItemModRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_unsuccessful_transfer: OCTET_STRING_37,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToModifyItemModResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToModifyListModCfm(
    pub Vec<PDUSessionResourceFailedToModifyItemModCfm>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToModifyListModRes(
    pub Vec<PDUSessionResourceFailedToModifyItemModRes>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToResumeItemRESReq {
    pub pdu_session_id: PDUSessionID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToResumeItemRESRes {
    pub pdu_session_id: PDUSessionID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToResumeItemRESResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToResumeListRESReq(
    pub Vec<PDUSessionResourceFailedToResumeItemRESReq>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToResumeListRESRes(
    pub Vec<PDUSessionResourceFailedToResumeItemRESRes>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemCxtFail {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer: OCTET_STRING_38,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemCxtRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer: OCTET_STRING_39,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemCxtResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemHOAck {
    pub pdu_session_id: PDUSessionID,
    pub handover_resource_allocation_unsuccessful_transfer: OCTET_STRING_40,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemHOAckIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemPSReq {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_setup_failed_transfer: OCTET_STRING_41,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemPSReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceFailedToSetupItemSURes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_unsuccessful_transfer: OCTET_STRING_42,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceFailedToSetupItemSUResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListCxtFail(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtFail>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListCxtRes(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtRes>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListHOAck(
    pub Vec<PDUSessionResourceFailedToSetupItemHOAck>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListPSReq(
    pub Vec<PDUSessionResourceFailedToSetupItemPSReq>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceFailedToSetupListSURes(
    pub Vec<PDUSessionResourceFailedToSetupItemSURes>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceHandoverItem {
    pub pdu_session_id: PDUSessionID,
    pub handover_command_transfer: OCTET_STRING_43,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceHandoverItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceHandoverList(pub Vec<PDUSessionResourceHandoverItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceInformationItem {
    pub pdu_session_id: PDUSessionID,
    pub qos_flow_information_list: QosFlowInformationList,
    #[asn(optional_idx = 0)]
    pub dr_bs_to_qos_flows_mapping_list: Option<DRBsToQosFlowsMappingList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceInformationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceInformationList(pub Vec<PDUSessionResourceInformationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemCxtRelCpl {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemCxtRelCplIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemCxtRelReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemCxtRelReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceItemHORqd {
    pub pdu_session_id: PDUSessionID,
    pub handover_required_transfer: OCTET_STRING_44,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceItemHORqdIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListCxtRelCpl(pub Vec<PDUSessionResourceItemCxtRelCpl>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListCxtRelReq(pub Vec<PDUSessionResourceItemCxtRelReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceListHORqd(pub Vec<PDUSessionResourceItemHORqd>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyConfirm {
    pub protocol_i_es: PDUSessionResourceModifyConfirmProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PDUSessionResourceModifyConfirmTransfer {
    pub qos_flow_modify_confirm_list: QosFlowModifyConfirmList,
    pub ulngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub additional_ng_uuptnl_information: Option<UPTransportLayerInformationPairList>,
    #[asn(optional_idx = 1)]
    pub qos_flow_failed_to_modify_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PDUSessionResourceModifyConfirmTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyIndication {
    pub protocol_i_es: PDUSessionResourceModifyIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyIndicationTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyIndicationTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModCfm {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_confirm_transfer: OCTET_STRING_45,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModCfmIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModInd {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_indication_transfer: OCTET_STRING_46,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModIndIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyItemModReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    pub pdu_session_resource_modify_request_transfer: OCTET_STRING_47,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceModifyItemModRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_modify_response_transfer: OCTET_STRING_48,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceModifyItemModResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModCfm(pub Vec<PDUSessionResourceModifyItemModCfm>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModInd(pub Vec<PDUSessionResourceModifyItemModInd>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModReq(pub Vec<PDUSessionResourceModifyItemModReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceModifyListModRes(pub Vec<PDUSessionResourceModifyItemModRes>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyRequest {
    pub protocol_i_es: PDUSessionResourceModifyRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyRequestTransfer {
    pub protocol_i_es: PDUSessionResourceModifyRequestTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceModifyResponse {
    pub protocol_i_es: PDUSessionResourceModifyResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 6)]
pub struct PDUSessionResourceModifyResponseTransfer {
    #[asn(optional_idx = 0)]
    pub dl_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub ul_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 2)]
    pub qos_flow_add_or_modify_response_list: Option<QosFlowAddOrModifyResponseList>,
    #[asn(optional_idx = 3)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 4)]
    pub qos_flow_failed_to_add_or_modify_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 5)]
    pub ie_extensions: Option<PDUSessionResourceModifyResponseTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceModifyUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceNotify {
    pub protocol_i_es: PDUSessionResourceNotifyProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceNotifyItem {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_notify_transfer: OCTET_STRING_49,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceNotifyItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceNotifyList(pub Vec<PDUSessionResourceNotifyItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceNotifyReleasedTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceNotifyReleasedTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PDUSessionResourceNotifyTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_notify_list: Option<QosFlowNotifyList>,
    #[asn(optional_idx = 1)]
    pub qos_flow_released_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PDUSessionResourceNotifyTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceReleaseCommand {
    pub protocol_i_es: PDUSessionResourceReleaseCommandProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleaseCommandTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleaseCommandTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceReleaseResponse {
    pub protocol_i_es: PDUSessionResourceReleaseResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleaseResponseTransfer {
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleaseResponseTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemNot {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_notify_released_transfer: OCTET_STRING_50,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemNotIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemPSAck {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_unsuccessful_transfer: OCTET_STRING_51,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemPSAckIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemPSFail {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_unsuccessful_transfer: OCTET_STRING_52,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemPSFailIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceReleasedItemRelRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_release_response_transfer: OCTET_STRING_53,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceReleasedItemRelResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListNot(pub Vec<PDUSessionResourceReleasedItemNot>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListPSAck(pub Vec<PDUSessionResourceReleasedItemPSAck>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListPSFail(pub Vec<PDUSessionResourceReleasedItemPSFail>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceReleasedListRelRes(pub Vec<PDUSessionResourceReleasedItemRelRes>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceResumeItemRESReq {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_resume_request_transfer: OCTET_STRING_54,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceResumeItemRESReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceResumeItemRESRes {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_resume_response_transfer: OCTET_STRING_55,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceResumeItemRESResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceResumeListRESReq(pub Vec<PDUSessionResourceResumeItemRESReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceResumeListRESRes(pub Vec<PDUSessionResourceResumeItemRESRes>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSecondaryRATUsageItem {
    pub pdu_session_id: PDUSessionID,
    pub secondary_rat_data_usage_report_transfer: OCTET_STRING_56,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSecondaryRATUsageItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSecondaryRATUsageList(
    pub Vec<PDUSessionResourceSecondaryRATUsageItem>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupItemCxtReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    pub s_nssai: S_NSSAI,
    pub pdu_session_resource_setup_request_transfer: OCTET_STRING_57,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemCxtReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemCxtRes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_response_transfer: OCTET_STRING_58,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemCxtResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemHOReq {
    pub pdu_session_id: PDUSessionID,
    pub s_nssai: S_NSSAI,
    pub handover_request_transfer: OCTET_STRING_59,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemHOReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupItemSUReq {
    pub pdu_session_id: PDUSessionID,
    #[asn(optional_idx = 0)]
    pub pdu_session_nas_pdu: Option<NAS_PDU>,
    pub s_nssai: S_NSSAI,
    pub pdu_session_resource_setup_request_transfer: OCTET_STRING_60,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemSUReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSetupItemSURes {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_setup_response_transfer: OCTET_STRING_61,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSetupItemSUResIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListCxtReq(pub Vec<PDUSessionResourceSetupItemCxtReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListCxtRes(pub Vec<PDUSessionResourceSetupItemCxtRes>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListHOReq(pub Vec<PDUSessionResourceSetupItemHOReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListSUReq(pub Vec<PDUSessionResourceSetupItemSUReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSetupListSURes(pub Vec<PDUSessionResourceSetupItemSURes>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupRequest {
    pub protocol_i_es: PDUSessionResourceSetupRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupRequestTransfer {
    pub protocol_i_es: PDUSessionResourceSetupRequestTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PDUSessionResourceSetupResponse {
    pub protocol_i_es: PDUSessionResourceSetupResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct PDUSessionResourceSetupResponseTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTNLInformationList>,
    #[asn(optional_idx = 1)]
    pub security_result: Option<SecurityResult>,
    #[asn(optional_idx = 2)]
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<PDUSessionResourceSetupResponseTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PDUSessionResourceSetupUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSuspendItemSUSReq {
    pub pdu_session_id: PDUSessionID,
    pub ue_context_suspend_request_transfer: OCTET_STRING_62,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSuspendItemSUSReqIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSuspendListSUSReq(pub Vec<PDUSessionResourceSuspendItemSUSReq>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceSwitchedItem {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_acknowledge_transfer: OCTET_STRING_63,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceSwitchedItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceSwitchedList(pub Vec<PDUSessionResourceSwitchedItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToBeSwitchedDLItem {
    pub pdu_session_id: PDUSessionID,
    pub path_switch_request_transfer: OCTET_STRING_64,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToBeSwitchedDLItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToBeSwitchedDLList(pub Vec<PDUSessionResourceToBeSwitchedDLItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToReleaseItemHOCmd {
    pub pdu_session_id: PDUSessionID,
    pub handover_preparation_unsuccessful_transfer: OCTET_STRING_65,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToReleaseItemHOCmdIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionResourceToReleaseItemRelCmd {
    pub pdu_session_id: PDUSessionID,
    pub pdu_session_resource_release_command_transfer: OCTET_STRING_66,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionResourceToReleaseItemRelCmdIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToReleaseListHOCmd(pub Vec<PDUSessionResourceToReleaseItemHOCmd>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PDUSessionResourceToReleaseListRelCmd(pub Vec<PDUSessionResourceToReleaseItemRelCmd>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct PDUSessionType(pub u8);
impl PDUSessionType {
    pub const IPV4: u8 = 0u8;
    pub const IPV6: u8 = 1u8;
    pub const IPV4V6: u8 = 2u8;
    pub const ETHERNET: u8 = 3u8;
    pub const UNSTRUCTURED: u8 = 4u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PDUSessionUsageReport {
    pub rat_type: ENUMERATED_67,
    pub pdu_session_timed_report_list: VolumeTimedReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PDUSessionUsageReportIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct PLMNIdentity(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PLMNSupportItem {
    pub plmn_identity: PLMNIdentity,
    pub slice_support_list: SliceSupportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PLMNSupportItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "12")]
pub struct PLMNSupportList(pub Vec<PLMNSupportItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PNI_NPN_MobilityInformation {
    pub allowed_pni_npi_list: Allowed_PNI_NPN_List,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PNI_NPN_MobilityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSCancelRequest {
    pub protocol_i_es: PWSCancelRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSCancelResponse {
    pub protocol_i_es: PWSCancelResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum PWSFailedCellIDList {
    #[asn(key = 0, extended = false)]
    EUTRA_CGI_PWSFailedList(EUTRA_CGIList),
    #[asn(key = 1, extended = false)]
    NR_CGI_PWSFailedList(NR_CGIList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(PWSFailedCellIDListchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSFailureIndication {
    pub protocol_i_es: PWSFailureIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSRestartIndication {
    pub protocol_i_es: PWSRestartIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1023", extensible = true)]
pub struct PacketDelayBudget(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PacketErrorRate {
    pub per_scalar: INTEGER_68,
    pub per_exponent: INTEGER_69,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PacketErrorRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1000", extensible = true)]
pub struct PacketLossRate(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Paging {
    pub protocol_i_es: PagingProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct Paging_Time_Window(pub u8);
impl Paging_Time_Window {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct Paging_eDRX_Cycle(pub u8);
impl Paging_eDRX_Cycle {
    pub const HFHALF: u8 = 0u8;
    pub const HF1: u8 = 1u8;
    pub const HF2: u8 = 2u8;
    pub const HF4: u8 = 3u8;
    pub const HF6: u8 = 4u8;
    pub const HF8: u8 = 5u8;
    pub const HF10: u8 = 6u8;
    pub const HF12: u8 = 7u8;
    pub const HF14: u8 = 8u8;
    pub const HF16: u8 = 9u8;
    pub const HF32: u8 = 10u8;
    pub const HF64: u8 = 11u8;
    pub const HF128: u8 = 12u8;
    pub const HF256: u8 = 13u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PagingAssisDataforCEcapabUE {
    pub eutra_cgi: EUTRA_CGI,
    pub coverage_enhancement_level: CoverageEnhancementLevel,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PagingAssisDataforCEcapabUEIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct PagingAttemptCount(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingAttemptInformation {
    pub paging_attempt_count: PagingAttemptCount,
    pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
    #[asn(optional_idx = 0)]
    pub next_paging_area_scope: Option<NextPagingAreaScope>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingAttemptInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct PagingDRX(pub u8);
impl PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PagingOrigin(pub u8);
impl PagingOrigin {
    pub const NON_3GPP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct PagingPriority(pub u8);
impl PagingPriority {
    pub const PRIOLEVEL1: u8 = 0u8;
    pub const PRIOLEVEL2: u8 = 1u8;
    pub const PRIOLEVEL3: u8 = 2u8;
    pub const PRIOLEVEL4: u8 = 3u8;
    pub const PRIOLEVEL5: u8 = 4u8;
    pub const PRIOLEVEL6: u8 = 5u8;
    pub const PRIOLEVEL7: u8 = 6u8;
    pub const PRIOLEVEL8: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "20")]
pub struct PagingProbabilityInformation(pub u8);
impl PagingProbabilityInformation {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P35: u8 = 7u8;
    pub const P40: u8 = 8u8;
    pub const P45: u8 = 9u8;
    pub const P50: u8 = 10u8;
    pub const P55: u8 = 11u8;
    pub const P60: u8 = 12u8;
    pub const P65: u8 = 13u8;
    pub const P70: u8 = 14u8;
    pub const P75: u8 = 15u8;
    pub const P80: u8 = 16u8;
    pub const P85: u8 = 17u8;
    pub const P90: u8 = 18u8;
    pub const P95: u8 = 19u8;
    pub const P100: u8 = 20u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingeDRXInformation {
    pub paging_e_drx_cycle: Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub paging_time_window: Option<Paging_Time_Window>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingeDRXInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequest {
    pub protocol_i_es: PathSwitchRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestAcknowledge {
    pub protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PathSwitchRequestAcknowledgeTransfer {
    #[asn(optional_idx = 0)]
    pub ul_ngu_up_tnl_information: Option<UPTransportLayerInformation>,
    #[asn(optional_idx = 1)]
    pub security_indication: Option<SecurityIndication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PathSwitchRequestAcknowledgeTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestFailure {
    pub protocol_i_es: PathSwitchRequestFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PathSwitchRequestSetupFailedTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PathSwitchRequestSetupFailedTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PathSwitchRequestTransfer {
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub dl_ngu_tnl_information_reused: Option<DL_NGU_TNLInformationReused>,
    #[asn(optional_idx = 1)]
    pub user_plane_security_information: Option<UserPlaneSecurityInformation>,
    pub qos_flow_accepted_list: QosFlowAcceptedList,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PathSwitchRequestTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PathSwitchRequestUnsuccessfulTransfer {
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PathSwitchRequestUnsuccessfulTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PedestrianUE(pub u8);
impl PedestrianUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct PeriodicRegistrationUpdateTimer(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "640000", extensible = true)]
pub struct Periodicity(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct PortNumber(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Pre_emptionCapability(pub u8);
impl Pre_emptionCapability {
    pub const SHALL_NOT_TRIGGER_PRE_EMPTION: u8 = 0u8;
    pub const MAY_TRIGGER_PRE_EMPTION: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Pre_emptionVulnerability(pub u8);
impl Pre_emptionVulnerability {
    pub const NOT_PRE_EMPTABLE: u8 = 0u8;
    pub const PRE_EMPTABLE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Presence(pub u8);
impl Presence {
    pub const OPTIONAL: u8 = 0u8;
    pub const CONDITIONAL: u8 = 1u8;
    pub const MANDATORY: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "15")]
pub struct PriorityLevelARP(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "127", extensible = true)]
pub struct PriorityLevelQos(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PrivacyIndicator(pub u8);
impl PrivacyIndicator {
    pub const IMMEDIATE_MDT: u8 = 0u8;
    pub const LOGGED_MDT: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PrivateIE_ID {
    #[asn(key = 0, extended = false)]
    Local(INTEGER_70),
    #[asn(key = 1, extended = false)]
    Global(OBJECT_IDENTIFIER_71),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PrivateMessage {
    pub private_i_es: PrivateMessagePrivateIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ProcedureCode(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum ProcedureStageChoice {
    #[asn(key = 0, extended = false)]
    First_dl_count(FirstDLCount),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(ProcedureStageChoicechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolExtensionID(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolIE_ID(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QoSFlowsUsageReport_Item {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub rat_type: ENUMERATED_72,
    pub qo_s_flows_timed_report_list: VolumeTimedReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QoSFlowsUsageReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QoSFlowsUsageReportList(pub Vec<QoSFlowsUsageReport_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum QosCharacteristics {
    #[asn(key = 0, extended = false)]
    NonDynamic5QI(NonDynamic5QIDescriptor),
    #[asn(key = 1, extended = false)]
    Dynamic5QI(Dynamic5QIDescriptor),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(QosCharacteristicschoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowAcceptedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowAcceptedItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAcceptedList(pub Vec<QosFlowAcceptedItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct QosFlowAddOrModifyRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub qos_flow_level_qos_parameters: Option<QosFlowLevelQosParameters>,
    #[asn(optional_idx = 1)]
    pub e_rab_id: Option<E_RAB_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<QosFlowAddOrModifyRequestItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAddOrModifyRequestList(pub Vec<QosFlowAddOrModifyRequestItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowAddOrModifyResponseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowAddOrModifyResponseItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowAddOrModifyResponseList(pub Vec<QosFlowAddOrModifyResponseItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct QosFlowFeedbackItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub update_feedback: Option<UpdateFeedback>,
    #[asn(optional_idx = 1)]
    pub c_npacket_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    #[asn(optional_idx = 2)]
    pub c_npacket_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<QosFlowFeedbackItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowFeedbackList(pub Vec<QosFlowFeedbackItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "63", extensible = true)]
pub struct QosFlowIdentifier(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowInformationItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DLForwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowInformationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowInformationList(pub Vec<QosFlowInformationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowItemWithDataForwarding {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub data_forwarding_accepted: Option<DataForwardingAccepted>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowItemWithDataForwardingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    #[asn(optional_idx = 0)]
    pub gbr_qos_information: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
    #[asn(optional_idx = 2)]
    pub additional_qos_flow_information: Option<AdditionalQosFlowInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<QosFlowLevelQosParametersIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowListWithCause(pub Vec<QosFlowWithCauseItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowListWithDataForwarding(pub Vec<QosFlowItemWithDataForwarding>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowModifyConfirmItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowModifyConfirmItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowModifyConfirmList(pub Vec<QosFlowModifyConfirmItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowNotifyItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub notification_cause: NotificationCause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowNotifyItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowNotifyList(pub Vec<QosFlowNotifyItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowParametersItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub alternative_qo_s_para_set_list: Option<AlternativeQoSParaSetList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowParametersItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowParametersList(pub Vec<QosFlowParametersItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowPerTNLInformation {
    pub up_transport_layer_information: UPTransportLayerInformation,
    pub associated_qos_flow_list: AssociatedQosFlowList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowPerTNLInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowPerTNLInformationItem {
    pub qos_flow_per_tnl_information: QosFlowPerTNLInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowPerTNLInformationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct QosFlowPerTNLInformationList(pub Vec<QosFlowPerTNLInformationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct QosFlowSetupRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
    #[asn(optional_idx = 0)]
    pub e_rab_id: Option<E_RAB_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<QosFlowSetupRequestItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowSetupRequestList(pub Vec<QosFlowSetupRequestItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowToBeForwardedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowToBeForwardedItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct QosFlowToBeForwardedList(pub Vec<QosFlowToBeForwardedItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct QosFlowWithCauseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<QosFlowWithCauseItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "1800", extensible = true)]
pub struct QosMonitoringReportingFrequency(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct QosMonitoringRequest(pub u8);
impl QosMonitoringRequest {
    pub const UL: u8 = 0u8;
    pub const DL: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct RAN_UE_NGAP_ID(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANCPRelocationIndication {
    pub protocol_i_es: RANCPRelocationIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdate {
    pub protocol_i_es: RANConfigurationUpdateProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdateAcknowledge {
    pub protocol_i_es: RANConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RANConfigurationUpdateFailure {
    pub protocol_i_es: RANConfigurationUpdateFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct RANNodeName(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "UTF8String", sz_extensible = true, sz_lb = "1", sz_ub = "150")]
pub struct RANNodeNameUTF8String(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "VisibleString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct RANNodeNameVisibleString(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct RANPagingPriority(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RANStatusTransfer_TransparentContainer {
    pub dr_bs_subject_to_status_transfer_list: DRBsSubjectToStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RANStatusTransfer_TransparentContainerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RAT_Information(pub u8);
impl RAT_Information {
    pub const UNLICENSED: u8 = 0u8;
    pub const NB_IO_T: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct RATRestrictionInformation(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RATRestrictions(pub Vec<RATRestrictions_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RATRestrictions_Item {
    pub plmn_identity: PLMNIdentity,
    pub rat_restriction_information: RATRestrictionInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RATRestrictions_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RGLevelWirelineAccessCharacteristics(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RIMInformation {
    pub targetg_nb_set_id: GNBSetID,
    pub rim_rs_detection: ENUMERATED_73,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RIMInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RIMInformationTransfer {
    pub target_ran_node_id: TargetRANNodeID,
    pub source_ran_node_id: SourceRANNodeID,
    pub rim_information: RIMInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RIMInformationTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RNC_ID(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RRCContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "9")]
pub struct RRCEstablishmentCause(pub u8);
impl RRCEstablishmentCause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
    pub const MO_VOICE_CALL: u8 = 5u8;
    pub const MO_VIDEO_CALL: u8 = 6u8;
    pub const MO_SMS: u8 = 7u8;
    pub const MPS_PRIORITY_ACCESS: u8 = 8u8;
    pub const MCS_PRIORITY_ACCESS: u8 = 9u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RRCInactiveTransitionReport {
    pub protocol_i_es: RRCInactiveTransitionReportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct RRCInactiveTransitionReportRequest(pub u8);
impl RRCInactiveTransitionReportRequest {
    pub const SUBSEQUENT_STATE_TRANSITION_REPORT: u8 = 0u8;
    pub const SINGLE_RRC_CONNECTED_STATE_REPORT: u8 = 1u8;
    pub const CANCEL_REPORT: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RRCState(pub u8);
impl RRCState {
    pub const INACTIVE: u8 = 0u8;
    pub const CONNECTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RSN(pub u8);
impl RSN {
    pub const V1: u8 = 0u8;
    pub const V2: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct Range(pub u8);
impl Range {
    pub const M50: u8 = 0u8;
    pub const M80: u8 = 1u8;
    pub const M180: u8 = 2u8;
    pub const M200: u8 = 3u8;
    pub const M350: u8 = 4u8;
    pub const M400: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const M700: u8 = 7u8;
    pub const M1000: u8 = 8u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RecommendedCellItem {
    pub ngran_cgi: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<INTEGER_74>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RecommendedCellItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedCellList(pub Vec<RecommendedCellItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedCellsForPaging {
    pub recommended_cell_list: RecommendedCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedCellsForPagingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedRANNodeItem {
    pub amf_paging_target: AMFPagingTarget,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedRANNodeItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedRANNodeList(pub Vec<RecommendedRANNodeItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedRANNodesForPaging {
    pub recommended_ran_node_list: RecommendedRANNodeList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedRANNodesForPagingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct RedirectionVoiceFallback(pub u8);
impl RedirectionVoiceFallback {
    pub const POSSIBLE: u8 = 0u8;
    pub const NOT_POSSIBLE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RedundantPDUSessionInformation {
    pub rsn: RSN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RedundantPDUSessionInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct RedundantQosFlowIndicator(pub u8);
impl RedundantQosFlowIndicator {
    pub const TRUE: u8 = 0u8;
    pub const FALSE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReflectiveQosAttribute(pub u8);
impl ReflectiveQosAttribute {
    pub const SUBJECT_TO: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "32"
)]
pub struct RejectedNSSAIinPLMN(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "32"
)]
pub struct RejectedNSSAIinTA(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct RelativeAMFCapacity(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "131071")]
pub struct RepetitionPeriod(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportAmountMDT(pub u8);
impl ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const RINFINITY: u8 = 7u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReportArea(pub u8);
impl ReportArea {
    pub const CELL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "12")]
pub struct ReportIntervalMDT(pub u8);
impl ReportIntervalMDT {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RerouteNASRequest {
    pub protocol_i_es: RerouteNASRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ResetAll(pub u8);
impl ResetAll {
    pub const RESET_ALL: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum ResetType {
    #[asn(key = 0, extended = false)]
    NG_Interface(ResetAll),
    #[asn(key = 1, extended = false)]
    PartOfNG_Interface(UE_associatedLogicalNG_connectionList),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(ResetTypechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEInformation {
    pub protocol_i_es: RetrieveUEInformationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct RoutingID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct S_NSSAI {
    pub sst: SST,
    #[asn(optional_idx = 0)]
    pub sd: Option<SD>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<S_NSSAIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct SCTP_TLAs(pub Vec<TransportLayerAddress>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct SD(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SNPN_MobilityInformation {
    pub serving_nid: NID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SNPN_MobilityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONConfigurationTransfer {
    pub target_ran_node_id: TargetRANNodeID,
    pub source_ran_node_id: SourceRANNodeID,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub xn_tnl_configuration_info: Option<XnTNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONConfigurationTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SONInformation {
    #[asn(key = 0, extended = false)]
    SONInformationRequest(SONInformationRequest),
    #[asn(key = 1, extended = false)]
    SONInformationReply(SONInformationReply),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(SONInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONInformationReply {
    #[asn(optional_idx = 0)]
    pub xn_tnl_configuration_info: Option<XnTNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONInformationReplyIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum SONInformationReport {
    #[asn(key = 0, extended = false)]
    FailureIndicationInformation(FailureIndication),
    #[asn(key = 1, extended = false)]
    HOReportInformation(HOReport),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(SONInformationReportchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONInformationRequest(pub u8);
impl SONInformationRequest {
    pub const XN_TNL_CONFIGURATION_INFO: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SRVCCOperationPossible(pub u8);
impl SRVCCOperationPossible {
    pub const POSSIBLE: u8 = 0u8;
    pub const NOT_POSSIBLE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct SST(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ScheduledCommunicationTime {
    #[asn(optional_idx = 0)]
    pub dayof_week: Option<BIT_STRING_75>,
    #[asn(optional_idx = 1)]
    pub timeof_day_start: Option<INTEGER_76>,
    #[asn(optional_idx = 2)]
    pub timeof_day_end: Option<INTEGER_77>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecondaryRATDataUsageReport {
    pub protocol_i_es: SecondaryRATDataUsageReportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SecondaryRATDataUsageReportTransfer {
    #[asn(optional_idx = 0)]
    pub secondary_rat_usage_information: Option<SecondaryRATUsageInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SecondaryRATDataUsageReportTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SecondaryRATUsageInformation {
    #[asn(optional_idx = 0)]
    pub pdu_session_usage_report: Option<PDUSessionUsageReport>,
    #[asn(optional_idx = 1)]
    pub qos_flows_usage_report_list: Option<QoSFlowsUsageReportList>,
    #[asn(optional_idx = 2)]
    pub ie_extension: Option<SecondaryRATUsageInformationIE_Extension>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityContext {
    pub next_hop_chaining_count: NextHopChainingCount,
    pub next_hop_nh: SecurityKey,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityContextIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SecurityIndication {
    pub integrity_protection_indication: IntegrityProtectionIndication,
    pub confidentiality_protection_indication: ConfidentialityProtectionIndication,
    #[asn(optional_idx = 0)]
    pub maximum_integrity_protected_data_rate_ul: Option<MaximumIntegrityProtectedDataRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SecurityIndicationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SecurityKey(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityResult {
    pub integrity_protection_result: IntegrityProtectionResult,
    pub confidentiality_protection_result: ConfidentialityProtectionResult,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityResultIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SensorMeasConfig(pub u8);
impl SensorMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SensorMeasConfigNameItem {
    pub sensor_name_config: SensorNameConfig,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SensorMeasConfigNameItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct SensorMeasConfigNameList(pub Vec<SensorMeasConfigNameItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SensorMeasurementConfiguration {
    pub sensor_meas_config: SensorMeasConfig,
    #[asn(optional_idx = 0)]
    pub sensor_meas_config_name_list: Option<SensorMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SensorMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum SensorNameConfig {
    #[asn(key = 0, extended = false)]
    UncompensatedBarometricConfig(ENUMERATED_78),
    #[asn(key = 1, extended = false)]
    UeSpeedConfig(ENUMERATED_79),
    #[asn(key = 2, extended = false)]
    UeOrientationConfig(ENUMERATED_80),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(SensorNameConfigchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SerialNumber(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct ServedGUAMIItem {
    pub guami: GUAMI,
    #[asn(optional_idx = 0)]
    pub backup_amf_name: Option<AMFName>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<ServedGUAMIItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedGUAMIList(pub Vec<ServedGUAMIItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ServiceAreaInformation(pub Vec<ServiceAreaInformation_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ServiceAreaInformation_Item {
    pub plmn_identity: PLMNIdentity,
    #[asn(optional_idx = 0)]
    pub allowed_ta_cs: Option<AllowedTACs>,
    #[asn(optional_idx = 1)]
    pub not_allowed_ta_cs: Option<NotAllowedTACs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ServiceAreaInformation_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct SgNB_UE_X2AP_ID(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SliceOverloadItem {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SliceOverloadItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct SliceOverloadList(pub Vec<SliceOverloadItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SliceSupportItem {
    pub s_nssai: S_NSSAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SliceSupportItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct SliceSupportList(pub Vec<SliceSupportItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainer {
    pub rrc_container: RRCContainer,
    #[asn(optional_idx = 0)]
    pub pdu_session_resource_information_list: Option<PDUSessionResourceInformationList>,
    #[asn(optional_idx = 1)]
    pub e_rab_information_list: Option<E_RABInformationList>,
    pub target_cell_id: NGRAN_CGI,
    #[asn(optional_idx = 2)]
    pub index_to_rfsp: Option<IndexToRFSP>,
    pub ue_history_information: UEHistoryInformation,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SourceOfUEActivityBehaviourInformation(pub u8);
impl SourceOfUEActivityBehaviourInformation {
    pub const SUBSCRIPTION_INFORMATION: u8 = 0u8;
    pub const STATISTICS: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SourceRANNodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceRANNodeIDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SourceToTarget_AMFInformationReroute {
    #[asn(optional_idx = 0)]
    pub configured_nssai: Option<ConfiguredNSSAI>,
    #[asn(optional_idx = 1)]
    pub rejected_nssa_iin_plmn: Option<RejectedNSSAIinPLMN>,
    #[asn(optional_idx = 2)]
    pub rejected_nssa_iin_ta: Option<RejectedNSSAIinTA>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SourceToTarget_AMFInformationRerouteIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct SourceToTarget_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: SuccessfulOutcomeValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SupportedTAItem {
    pub tac: TAC,
    pub broadcast_plmn_list: BroadcastPLMNList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SupportedTAItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedTAList(pub Vec<SupportedTAItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Suspend_Request_Indication(pub u8);
impl Suspend_Request_Indication {
    pub const SUSPEND_REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Suspend_Response_Indication(pub u8);
impl Suspend_Response_Indication {
    pub const SUSPEND_INDICATED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SuspendIndicator(pub u8);
impl SuspendIndicator {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedMDT {
    pub ta_listfor_mdt: TAListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedMDTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TAC(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI {
    pub plmn_identity: PLMNIdentity,
    pub tac: TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedMDT {
    pub tai_listfor_mdt: TAIListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedMDTIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastEUTRA(pub Vec<TAIBroadcastEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBroadcastEUTRA_Item {
    pub tai: TAI,
    pub completed_cells_in_tai_eutra: CompletedCellsInTAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBroadcastEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastNR(pub Vec<TAIBroadcastNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBroadcastNR_Item {
    pub tai: TAI,
    pub completed_cells_in_tai_nr: CompletedCellsInTAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBroadcastNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledEUTRA(pub Vec<TAICancelledEUTRA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAICancelledEUTRA_Item {
    pub tai: TAI,
    pub cancelled_cells_in_tai_eutra: CancelledCellsInTAI_EUTRA,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAICancelledEUTRA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledNR(pub Vec<TAICancelledNR_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAICancelledNR_Item {
    pub tai: TAI,
    pub cancelled_cells_in_tai_nr: CancelledCellsInTAI_NR,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAICancelledNR_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct TAIListForInactive(pub Vec<TAIListForInactiveItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIListForInactiveItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIListForInactiveItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct TAIListForPaging(pub Vec<TAIListForPagingItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIListForPagingItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIListForPagingItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct TAIListForRestart(pub Vec<TAI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForWarning(pub Vec<TAI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforMDT(pub Vec<TAI>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforMDT(pub Vec<TAC>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TNAP_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TNGF_ID {
    #[asn(key = 0, extended = false)]
    TNGF_ID(BIT_STRING_81),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(TNGF_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct TNLAddressWeightFactor(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TNLAssociationItem {
    pub tnl_association_address: CPTransportLayerInformation,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TNLAssociationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct TNLAssociationList(pub Vec<TNLAssociationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct TNLAssociationUsage(pub u8);
impl TNLAssociationUsage {
    pub const UE: u8 = 0u8;
    pub const NON_UE: u8 = 1u8;
    pub const BOTH: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TSCAssistanceInformation {
    pub periodicity: Periodicity,
    #[asn(optional_idx = 0)]
    pub burst_arrival_time: Option<BurstArrivalTime>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TSCAssistanceInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct TSCTrafficCharacteristics {
    #[asn(optional_idx = 0)]
    pub tsc_assistance_information_dl: Option<TSCAssistanceInformation>,
    #[asn(optional_idx = 1)]
    pub tsc_assistance_information_ul: Option<TSCAssistanceInformation>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<TSCTrafficCharacteristicsIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TWAP_ID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum TWIF_ID {
    #[asn(key = 0, extended = false)]
    TWIF_ID(BIT_STRING_82),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(TWIF_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum TargetID {
    #[asn(key = 0, extended = false)]
    TargetRANNodeID(TargetRANNodeID),
    #[asn(key = 1, extended = false)]
    TargeteNB_ID(TargeteNB_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(TargetIDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainer {
    pub cell_cag_information: Cell_CAGInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions:
        Option<TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainer {
    pub rrc_container: RRCContainer,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetRANNodeID {
    pub global_ran_node_id: GlobalRANNodeID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetRANNodeIDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TargetRNC_ID {
    pub lai: LAI,
    pub rnc_id: RNC_ID,
    #[asn(optional_idx = 0)]
    pub extended_rnc_id: Option<ExtendedRNC_ID>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TargetRNC_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargetToSource_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ID {
    pub global_enb_id: GlobalNgENB_ID,
    pub selected_eps_tai: EPS_TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_IDIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct TargettoSource_Failure_TransparentContainer(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_RSRP(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_RSRQ(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct Threshold_SINR(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct TimeStamp(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "15")]
pub struct TimeToTrigger(pub u8);
impl TimeToTrigger {
    pub const MS0: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS64: u8 = 2u8;
    pub const MS80: u8 = 3u8;
    pub const MS100: u8 = 4u8;
    pub const MS128: u8 = 5u8;
    pub const MS160: u8 = 6u8;
    pub const MS256: u8 = 7u8;
    pub const MS320: u8 = 8u8;
    pub const MS480: u8 = 9u8;
    pub const MS512: u8 = 10u8;
    pub const MS640: u8 = 11u8;
    pub const MS1024: u8 = 12u8;
    pub const MS1280: u8 = 13u8;
    pub const MS2560: u8 = 14u8;
    pub const MS5120: u8 = 15u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TimeToWait(pub u8);
impl TimeToWait {
    pub const V1S: u8 = 0u8;
    pub const V2S: u8 = 1u8;
    pub const V5S: u8 = 2u8;
    pub const V10S: u8 = 3u8;
    pub const V20S: u8 = 4u8;
    pub const V60S: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct TimeUEStayedInCell(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "40950")]
pub struct TimeUEStayedInCellEnhancedGranularity(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct TimerApproachForGUAMIRemoval(pub u8);
impl TimerApproachForGUAMIRemoval {
    pub const APPLY_TIMER: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TooearlyIntersystemHO {
    pub sourcecell_id: EUTRA_CGI,
    pub failurecell_id: NGRAN_CGI,
    #[asn(optional_idx = 0)]
    pub uerlf_report_container: Option<UERLFReportContainer>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TooearlyIntersystemHOIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TraceActivation {
    pub ngran_trace_id: NGRANTraceID,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TraceActivationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TraceDepth(pub u8);
impl TraceDepth {
    pub const MINIMUM: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const MAXIMUM: u8 = 2u8;
    pub const MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 3u8;
    pub const MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 4u8;
    pub const MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 5u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceFailureIndication {
    pub protocol_i_es: TraceFailureIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceStart {
    pub protocol_i_es: TraceStartProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "99")]
pub struct TrafficLoadReductionIndication(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TransportLayerAddress(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct TriggeringMessage(pub u8);
impl TriggeringMessage {
    pub const INITIATING_MESSAGE: u8 = 0u8;
    pub const SUCCESSFUL_OUTCOME: u8 = 1u8;
    pub const UNSUCCESSFULL_OUTCOME: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct TypeOfError(pub u8);
impl TypeOfError {
    pub const NOT_UNDERSTOOD: u8 = 0u8;
    pub const MISSING: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct UE_DifferentiationInfo {
    #[asn(optional_idx = 0)]
    pub periodic_communication_indicator: Option<ENUMERATED_83>,
    #[asn(optional_idx = 1)]
    pub periodic_time: Option<INTEGER_84>,
    #[asn(optional_idx = 2)]
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    #[asn(optional_idx = 3)]
    pub stationary_indication: Option<ENUMERATED_85>,
    #[asn(optional_idx = 4)]
    pub traffic_profile: Option<ENUMERATED_86>,
    #[asn(optional_idx = 5)]
    pub battery_indication: Option<ENUMERATED_87>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<UE_DifferentiationInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_NGAP_ID_pair {
    pub amf_ue_ngap_id: AMF_UE_NGAP_ID,
    pub ran_ue_ngap_id: RAN_UE_NGAP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_NGAP_ID_pairIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UE_NGAP_IDs {
    #[asn(key = 0, extended = false)]
    UE_NGAP_ID_pair(UE_NGAP_ID_pair),
    #[asn(key = 1, extended = false)]
    AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UE_NGAP_IDschoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UE_UP_CIoT_Support(pub u8);
impl UE_UP_CIoT_Support {
    pub const SUPPORTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UE_associatedLogicalNG_connectionItem {
    #[asn(optional_idx = 0)]
    pub amf_ue_ngap_id: Option<AMF_UE_NGAP_ID>,
    #[asn(optional_idx = 1)]
    pub ran_ue_ngap_id: Option<RAN_UE_NGAP_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UE_associatedLogicalNG_connectionItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65536"
)]
pub struct UE_associatedLogicalNG_connectionList(pub Vec<UE_associatedLogicalNG_connectionItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAggregateMaximumBitRate {
    pub ue_aggregate_maximum_bit_rate_dl: BitRate,
    pub ue_aggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAggregateMaximumBitRateIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UECapabilityInfoRequest(pub u8);
impl UECapabilityInfoRequest {
    pub const REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationFailure {
    pub protocol_i_es: UEContextModificationFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationRequest {
    pub protocol_i_es: UEContextModificationRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationResponse {
    pub protocol_i_es: UEContextModificationResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseCommand {
    pub protocol_i_es: UEContextReleaseCommandProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseComplete {
    pub protocol_i_es: UEContextReleaseCompleteProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseRequest {
    pub protocol_i_es: UEContextReleaseRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UEContextRequest(pub u8);
impl UEContextRequest {
    pub const REQUESTED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeFailure {
    pub protocol_i_es: UEContextResumeFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeRequest {
    pub protocol_i_es: UEContextResumeRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextResumeRequestTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextResumeRequestTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeResponse {
    pub protocol_i_es: UEContextResumeResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextResumeResponseTransfer {
    #[asn(optional_idx = 0)]
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextResumeResponseTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendFailure {
    pub protocol_i_es: UEContextSuspendFailureProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendRequest {
    pub protocol_i_es: UEContextSuspendRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UEContextSuspendRequestTransfer {
    #[asn(optional_idx = 0)]
    pub suspend_indicator: Option<SuspendIndicator>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UEContextSuspendRequestTransferIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendResponse {
    pub protocol_i_es: UEContextSuspendResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UEHistoryInformation(pub Vec<LastVisitedCellItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEHistoryInformationFromTheUE {
    #[asn(key = 0, extended = false)]
    NR(NRMobilityHistoryReport),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEHistoryInformationFromTheUEchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEIdentityIndexValue {
    #[asn(key = 0, extended = false)]
    IndexLength10(BIT_STRING_88),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEIdentityIndexValuechoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEInformationTransfer {
    pub protocol_i_es: UEInformationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEPagingIdentity {
    #[asn(key = 0, extended = false)]
    FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UEPagingIdentitychoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct UEPresence(pub u8);
impl UEPresence {
    pub const IN: u8 = 0u8;
    pub const OUT: u8 = 1u8;
    pub const UNKNOWN: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEPresenceInAreaOfInterestItem {
    pub location_reporting_reference_id: LocationReportingReferenceID,
    pub ue_presence: UEPresence,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEPresenceInAreaOfInterestItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct UEPresenceInAreaOfInterestList(pub Vec<UEPresenceInAreaOfInterestItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UERLFReportContainer {
    #[asn(key = 0, extended = false)]
    NR(NRUERLFReportContainer),
    #[asn(key = 1, extended = false)]
    LTE(LTEUERLFReportContainer),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UERLFReportContainerchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapability(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityCheckRequest {
    pub protocol_i_es: UERadioCapabilityCheckRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityCheckResponse {
    pub protocol_i_es: UERadioCapabilityCheckResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UERadioCapabilityForPaging {
    #[asn(optional_idx = 0)]
    pub ue_radio_capability_for_paging_of_nr: Option<UERadioCapabilityForPagingOfNR>,
    #[asn(optional_idx = 1)]
    pub ue_radio_capability_for_paging_of_eutra: Option<UERadioCapabilityForPagingOfEUTRA>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UERadioCapabilityForPagingIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfEUTRA(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfNB_IoT(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPagingOfNR(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityID(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingRequest {
    pub protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingResponse {
    pub protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityInfoIndication {
    pub protocol_i_es: UERadioCapabilityInfoIndicationProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UERetentionInformation(pub u8);
impl UERetentionInformation {
    pub const UES_RETAINED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESecurityCapabilities {
    pub n_rencryption_algorithms: NRencryptionAlgorithms,
    pub n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms,
    pub eutr_aencryption_algorithms: EUTRAencryptionAlgorithms,
    pub eutr_aintegrity_protection_algorithms: EUTRAintegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESecurityCapabilitiesIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UETNLABindingReleaseRequest {
    pub protocol_i_es: UETNLABindingReleaseRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_CP_SecurityInformation {
    pub ul_nas_mac: UL_NAS_MAC,
    pub ul_nas_count: UL_NAS_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct UL_NAS_Count(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct UL_NAS_MAC(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_NGU_UP_TNLModifyItem {
    pub ul_ngu_up_tnl_information: UPTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_NGU_UP_TNLModifyItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct UL_NGU_UP_TNLModifyList(pub Vec<UL_NGU_UP_TNLModifyItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ULForwarding(pub u8);
impl ULForwarding {
    pub const UL_FORWARDING_PROPOSED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UPTransportLayerInformation {
    #[asn(key = 0, extended = false)]
    GTPTunnel(GTPTunnel),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(UPTransportLayerInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UPTransportLayerInformationItem {
    pub ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UPTransportLayerInformationItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct UPTransportLayerInformationList(pub Vec<UPTransportLayerInformationItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UPTransportLayerInformationPairItem {
    pub ul_ngu_up_tnl_information: UPTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UPTransportLayerInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UPTransportLayerInformationPairItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "3")]
pub struct UPTransportLayerInformationPairList(pub Vec<UPTransportLayerInformationPairItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "VisibleString")]
pub struct URI_address(pub String);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UnavailableGUAMIItem {
    pub guami: GUAMI,
    #[asn(optional_idx = 0)]
    pub timer_approach_for_guami_removal: Option<TimerApproachForGUAMIRemoval>,
    #[asn(optional_idx = 1)]
    pub backup_amf_name: Option<AMFName>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UnavailableGUAMIItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UnavailableGUAMIList(pub Vec<UnavailableGUAMIItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnsuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: UnsuccessfulOutcomeValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct UpdateFeedback(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNASTransport {
    pub protocol_i_es: UplinkNASTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNonUEAssociatedNRPPaTransport {
    pub protocol_i_es: UplinkNonUEAssociatedNRPPaTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANConfigurationTransfer {
    pub protocol_i_es: UplinkRANConfigurationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANEarlyStatusTransfer {
    pub protocol_i_es: UplinkRANEarlyStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRANStatusTransfer {
    pub protocol_i_es: UplinkRANStatusTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkRIMInformationTransfer {
    pub protocol_i_es: UplinkRIMInformationTransferProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkUEAssociatedNRPPaTransport {
    pub protocol_i_es: UplinkUEAssociatedNRPPaTransportProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = false)]
pub enum UserLocationInformation {
    #[asn(key = 0, extended = false)]
    UserLocationInformationEUTRA(UserLocationInformationEUTRA),
    #[asn(key = 1, extended = false)]
    UserLocationInformationNR(UserLocationInformationNR),
    #[asn(key = 2, extended = false)]
    UserLocationInformationN3IWF(UserLocationInformationN3IWF),
    #[asn(key = 3, extended = false)]
    Choice_Extensions(UserLocationInformationchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationEUTRA {
    pub eutra_cgi: EUTRA_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub time_stamp: Option<TimeStamp>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationEUTRAIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserLocationInformationN3IWF {
    pub ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserLocationInformationN3IWFIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationNR {
    pub nr_cgi: NR_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub time_stamp: Option<TimeStamp>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationNRIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationTNGF {
    pub tnap_id: TNAP_ID,
    pub ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub port_number: Option<PortNumber>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationTNGFIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct UserLocationInformationTWIF {
    pub twap_id: TWAP_ID,
    pub ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub port_number: Option<PortNumber>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<UserLocationInformationTWIFIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = false)]
pub enum UserLocationInformationW_AGF {
    #[asn(key = 0, extended = false)]
    GlobalLine_ID(GlobalLine_ID),
    #[asn(key = 1, extended = false)]
    HFCNode_ID(HFCNode_ID),
    #[asn(key = 2, extended = false)]
    Choice_Extensions(UserLocationInformationW_AGFchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserPlaneSecurityInformation {
    pub security_result: SecurityResult,
    pub security_indication: SecurityIndication,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserPlaneSecurityInformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VehicleUE(pub u8);
impl VehicleUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct VolumeTimedReport_Item {
    pub start_time_stamp: OCTET_STRING_89,
    pub end_time_stamp: OCTET_STRING_90,
    pub usage_count_ul: INTEGER_91,
    pub usage_count_dl: INTEGER_92,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<VolumeTimedReport_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct VolumeTimedReportList(pub Vec<VolumeTimedReport_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum W_AGF_ID {
    #[asn(key = 0, extended = false)]
    W_AGF_ID(BIT_STRING_93),
    #[asn(key = 1, extended = false)]
    Choice_Extensions(W_AGF_IDchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasConfig(pub u8);
impl WLANMeasConfig {
    pub const SETUP: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WLANMeasConfigNameItem {
    pub wlan_name: WLANName,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WLANMeasConfigNameItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLANMeasConfigNameList(pub Vec<WLANMeasConfigNameItem>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLANMeasurementConfiguration {
    pub wlan_meas_config: WLANMeasConfig,
    #[asn(optional_idx = 0)]
    pub wlan_meas_config_name_list: Option<WLANMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub wlan_rssi: Option<ENUMERATED_94>,
    #[asn(optional_idx = 2)]
    pub wlan_rtt: Option<ENUMERATED_95>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLANName(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WUS_Assistance_Information {
    pub paging_probability_information: PagingProbabilityInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WUS_Assistance_InformationIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct WarningAreaCoordinates(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = false)]
pub enum WarningAreaList {
    #[asn(key = 0, extended = false)]
    EUTRA_CGIListForWarning(EUTRA_CGIListForWarning),
    #[asn(key = 1, extended = false)]
    NR_CGIListForWarning(NR_CGIListForWarning),
    #[asn(key = 2, extended = false)]
    TAIListForWarning(TAIListForWarning),
    #[asn(key = 3, extended = false)]
    EmergencyAreaIDList(EmergencyAreaIDList),
    #[asn(key = 4, extended = false)]
    Choice_Extensions(WarningAreaListchoice_Extensions),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "9600"
)]
pub struct WarningMessageContents(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "50",
    sz_ub = "50"
)]
pub struct WarningSecurityInfo(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct WarningType(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningRequest {
    pub protocol_i_es: WriteReplaceWarningRequestProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningResponse {
    pub protocol_i_es: WriteReplaceWarningResponseProtocolIEs,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct XnExtTLA_Item {
    #[asn(optional_idx = 0)]
    pub i_psec_tla: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub gtp_tl_as: Option<XnGTP_TLAs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<XnExtTLA_ItemIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct XnExtTLAs(pub Vec<XnExtTLA_Item>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct XnGTP_TLAs(pub Vec<TransportLayerAddress>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct XnTLAs(pub Vec<TransportLayerAddress>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct XnTNLConfigurationInfo {
    pub xn_transport_layer_addresses: XnTLAs,
    #[asn(optional_idx = 0)]
    pub xn_extended_transport_layer_addresses: Option<XnExtTLAs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<XnTNLConfigurationInfoIE_Extensions>,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationSetupItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationSetupItemIE_Extensions(
    pub Vec<AMF_TNLAssociationSetupItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToAddItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToAddItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToAddItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 168)]
    Id_TNLAssociationTransportLayerAddressNGRAN(CPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToRemoveItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AMF_TNLAssociationToRemoveItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToRemoveItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToRemoveItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMF_TNLAssociationToUpdateItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AMF_TNLAssociationToUpdateItemIE_Extensions(
    pub Vec<AMF_TNLAssociationToUpdateItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMFCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFCPRelocationIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFCPRelocationIndicationProtocolIEs(
    pub Vec<AMFCPRelocationIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 6)]
    Id_AMF_TNLAssociationToAddList(AMF_TNLAssociationToAddList),
    #[asn(key = 7)]
    Id_AMF_TNLAssociationToRemoveList(AMF_TNLAssociationToRemoveList),
    #[asn(key = 8)]
    Id_AMF_TNLAssociationToUpdateList(AMF_TNLAssociationToUpdateList),
    #[asn(key = 1)]
    Id_AMFName(AMFName),
    #[asn(key = 274)]
    Id_Extended_AMFName(Extended_AMFName),
    #[asn(key = 80)]
    Id_PLMNSupportList(PLMNSupportList),
    #[asn(key = 86)]
    Id_RelativeAMFCapacity(RelativeAMFCapacity),
    #[asn(key = 96)]
    Id_ServedGUAMIList(ServedGUAMIList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateProtocolIEs(pub Vec<AMFConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 4)]
    Id_AMF_TNLAssociationFailedToSetupList(TNLAssociationList),
    #[asn(key = 5)]
    Id_AMF_TNLAssociationSetupList(AMF_TNLAssociationSetupList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<AMFConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMFConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFConfigurationUpdateFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFConfigurationUpdateFailureProtocolIEs(
    pub Vec<AMFConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFPagingTargetchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AMFStatusIndicationProtocolIEs_EntryValue {
    #[asn(key = 120)]
    Id_UnavailableGUAMIList(UnavailableGUAMIList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AMFStatusIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: AMFStatusIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct AMFStatusIndicationProtocolIEs(pub Vec<AMFStatusIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 183)]
    Id_AdditionalRedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AdditionalDLUPTNLInformationForHOItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AdditionalDLUPTNLInformationForHOItemIE_Extensions(
    pub Vec<AdditionalDLUPTNLInformationForHOItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllocationAndRetentionPriorityIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllocationAndRetentionPriorityIE_Extensions(
    pub Vec<AllocationAndRetentionPriorityIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_2(pub u8);
impl ENUMERATED_2 {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Allowed_PNI_NPN_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Allowed_PNI_NPN_ItemIE_Extensions(pub Vec<Allowed_PNI_NPN_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllowedNSSAI_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllowedNSSAI_ItemIE_Extensions(pub Vec<AllowedNSSAI_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AlternativeQoSParaSetItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AlternativeQoSParaSetItemIE_Extensions(
    pub Vec<AlternativeQoSParaSetItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestIE_Extensions(pub Vec<AreaOfInterestIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestCellItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestCellItemIE_Extensions(pub Vec<AreaOfInterestCellItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestItemIE_Extensions(pub Vec<AreaOfInterestItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestRANNodeItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestRANNodeItemIE_Extensions(
    pub Vec<AreaOfInterestRANNodeItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaOfInterestTAIItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaOfInterestTAIItemIE_Extensions(pub Vec<AreaOfInterestTAIItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct NULL_3;

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfMDT_EUTRAchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct NULL_4;

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfMDT_NRchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AreaScopeOfNeighCellsItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AreaScopeOfNeighCellsItemIE_Extensions(
    pub Vec<AreaScopeOfNeighCellsItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AssistanceDataForPagingIE_Extensions_EntryExtensionValue {
    #[asn(key = 260)]
    Id_NPN_PagingAssistanceInformation(NPN_PagingAssistanceInformation),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForPagingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AssistanceDataForPagingIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForPagingIE_Extensions(
    pub Vec<AssistanceDataForPagingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions(
    pub Vec<AssistanceDataForRecommendedCellsIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_5(pub u8);
impl ENUMERATED_5 {
    pub const UL: u8 = 0u8;
    pub const DL: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum AssociatedQosFlowItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssociatedQosFlowItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: AssociatedQosFlowItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssociatedQosFlowItemIE_Extensions(pub Vec<AssociatedQosFlowItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasConfigNameItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasConfigNameItemIE_Extensions(
    pub Vec<BluetoothMeasConfigNameItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_6(pub u8);
impl ENUMERATED_6 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasurementConfigurationIE_Extensions(
    pub Vec<BluetoothMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastCancelledAreaListchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastCompletedAreaListchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum BroadcastPLMNItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 271)]
    Id_ExtendedTAISliceSupportList(ExtendedSliceSupportList),
    #[asn(key = 258)]
    Id_NPN_Support(NPN_Support),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BroadcastPLMNItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: BroadcastPLMNItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BroadcastPLMNItemIE_Extensions(pub Vec<BroadcastPLMNItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNAssistedRANTuningIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNAssistedRANTuningIE_Extensions(pub Vec<CNAssistedRANTuningIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_7(pub u8);
impl ENUMERATED_7 {
    pub const EPC_FORBIDDEN: u8 = 0u8;
    pub const FIVE_GC_FORBIDDEN: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNTypeRestrictionsForEquivalentItemIE_Extensions(
    pub Vec<CNTypeRestrictionsForEquivalentItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct INTEGER_8(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct INTEGER_9(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueForPDCP_SN12IE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueForPDCP_SN12IE_Extensions(pub Vec<COUNTValueForPDCP_SN12IE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct INTEGER_10(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct INTEGER_11(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueForPDCP_SN18IE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueForPDCP_SN18IE_Extensions(pub Vec<COUNTValueForPDCP_SN18IE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CPTransportLayerInformationchoice_ExtensionsValue {
    #[asn(key = 169)]
    Id_EndpointIPAddressAndPort(EndpointIPAddressAndPort),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CPTransportLayerInformationchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CPTransportLayerInformationchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_EUTRA_ItemIE_Extensions(
    pub Vec<CancelledCellsInEAI_EUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInEAI_NR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInEAI_NR_ItemIE_Extensions(
    pub Vec<CancelledCellsInEAI_NR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_EUTRA_ItemIE_Extensions(
    pub Vec<CancelledCellsInTAI_EUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellsInTAI_NR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellsInTAI_NR_ItemIE_Extensions(
    pub Vec<CancelledCellsInTAI_NR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCellchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCellIDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidateCellIDIE_Extensions(pub Vec<CandidateCellIDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidateCellItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidateCellItemIE_Extensions(pub Vec<CandidateCellItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "1007", extensible = true)]
pub struct INTEGER_12(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "3279165")]
pub struct INTEGER_13(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CandidatePCIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CandidatePCIIE_Extensions(pub Vec<CandidatePCIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Causechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cell_CAGInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Cell_CAGInformationIE_Extensions(pub Vec<Cell_CAGInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDT_EUTRAIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDT_EUTRAIE_Extensions(pub Vec<CellBasedMDT_EUTRAIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDT_NRIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDT_NRIE_Extensions(pub Vec<CellBasedMDT_NRIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDBroadcastEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastEUTRA_ItemIE_Extensions(
    pub Vec<CellIDBroadcastEUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDBroadcastNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDBroadcastNR_ItemIE_Extensions(pub Vec<CellIDBroadcastNR_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDCancelledEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledEUTRA_ItemIE_Extensions(
    pub Vec<CellIDCancelledEUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDCancelledNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIDCancelledNR_ItemIE_Extensions(pub Vec<CellIDCancelledNR_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIDListForRestartchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CellTrafficTraceProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 43)]
    Id_NGRAN_CGI(NGRAN_CGI),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 256)]
    Id_PrivacyIndicator(PrivacyIndicator),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 109)]
    Id_TraceCollectionEntityIPAddress(TransportLayerAddress),
    #[asn(key = 257)]
    Id_TraceCollectionEntityURI(URI_address),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTrafficTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellTrafficTraceProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellTrafficTraceProtocolIEs(pub Vec<CellTrafficTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTypeIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellTypeIE_Extensions(pub Vec<CellTypeIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_EUTRA_ItemIE_Extensions(
    pub Vec<CompletedCellsInEAI_EUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInEAI_NR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInEAI_NR_ItemIE_Extensions(
    pub Vec<CompletedCellsInEAI_NR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_EUTRA_ItemIE_Extensions(
    pub Vec<CompletedCellsInTAI_EUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellsInTAI_NR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellsInTAI_NR_ItemIE_Extensions(
    pub Vec<CompletedCellsInTAI_NR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 212)]
    Id_DL_CP_SecurityInformation(DL_CP_SecurityInformation),
    #[asn(key = 226)]
    Id_EndIndication(EndIndication),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 210)]
    Id_NB_IoT_UEPriority(NB_IoT_UEPriority),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectionEstablishmentIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ConnectionEstablishmentIndicationProtocolIEs(
    pub Vec<ConnectionEstablishmentIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue {
    #[asn(key = 280)]
    Id_ExtendedUEIdentityIndexValue(ExtendedUEIdentityIndexValue),
    #[asn(key = 223)]
    Id_PagingeDRXInformation(PagingeDRXInformation),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        CoreNetworkAssistanceInformationForInactiveIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CoreNetworkAssistanceInformationForInactiveIE_Extensions(
    pub Vec<CoreNetworkAssistanceInformationForInactiveIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnosticsIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnosticsIE_Extensions(pub Vec<CriticalityDiagnosticsIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions(
    pub Vec<CriticalityDiagnostics_IE_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_14(pub u8);
impl ENUMERATED_14 {
    pub const DAPS_HO_REQUIRED: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSRequestInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSRequestInfoIE_Extensions(pub Vec<DAPSRequestInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_15(pub u8);
impl ENUMERATED_15 {
    pub const DAPS_HO_ACCEPTED: u8 = 0u8;
    pub const DAPS_HO_NOT_ACCEPTED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoIE_Extensions(pub Vec<DAPSResponseInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoItemIE_Extension(pub Vec<DAPSResponseInfoItemIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CP_SecurityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DL_CP_SecurityInformationIE_Extensions(
    pub Vec<DL_CP_SecurityInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDLchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDL12IE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusDL12IE_Extension(pub Vec<DRBStatusDL12IE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusDL18IE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusDL18IE_Extension(pub Vec<DRBStatusDL18IE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusULchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "1", sz_ub = "2048")]
pub struct BIT_STRING_16(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusUL12IE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusUL12IE_Extension(pub Vec<DRBStatusUL12IE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "131072"
)]
pub struct BIT_STRING_17(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBStatusUL18IE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBStatusUL18IE_Extension(pub Vec<DRBStatusUL18IE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension(
    pub Vec<DRBsSubjectToEarlyStatusTransfer_ItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue {
    #[asn(key = 159)]
    Id_OldAssociatedQosFlowList_ULendmarkerexpected(AssociatedQosFlowList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsSubjectToStatusTransferItemIE_Extension_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: DRBsSubjectToStatusTransferItemIE_Extension_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsSubjectToStatusTransferItemIE_Extension(
    pub Vec<DRBsSubjectToStatusTransferItemIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 266)]
    Id_DAPSRequestInfo(DAPSRequestInfo),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DRBsToQosFlowsMappingItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: DRBsToQosFlowsMappingItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DRBsToQosFlowsMappingItemIE_Extensions(
    pub Vec<DRBsToQosFlowsMappingItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataForwardingResponseDRBItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DataForwardingResponseDRBItemIE_Extensions(
    pub Vec<DataForwardingResponseDRBItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DataForwardingResponseERABListItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DataForwardingResponseERABListItemIE_Extensions(
    pub Vec<DataForwardingResponseERABListItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DeactivateTraceProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeactivateTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DeactivateTraceProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DeactivateTraceProtocolIEs(pub Vec<DeactivateTraceProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 226)]
    Id_EndIndication(EndIndication),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 48)]
    Id_OldAMF(AMFName),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 228)]
    Id_UECapabilityInfoRequest(UECapabilityInfoRequest),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNASTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNASTransportProtocolIEs(pub Vec<DownlinkNASTransportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNonUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<DownlinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 157)]
    Id_ENDC_SONConfigurationTransferDL(EN_DCSONConfigurationTransfer),
    #[asn(key = 250)]
    Id_IntersystemSONConfigurationTransferDL(IntersystemSONConfigurationTransfer),
    #[asn(key = 98)]
    Id_SONConfigurationTransferDL(SONConfigurationTransfer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANConfigurationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANConfigurationTransferProtocolIEs(
    pub Vec<DownlinkRANConfigurationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 268)]
    Id_EarlyStatusTransfer_TransparentContainer(EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANEarlyStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANEarlyStatusTransferProtocolIEs(
    pub Vec<DownlinkRANEarlyStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRANStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 84)]
    Id_RANStatusTransfer_TransparentContainer(RANStatusTransfer_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRANStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRANStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRANStatusTransferProtocolIEs(
    pub Vec<DownlinkRANStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkRIMInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 175)]
    Id_RIMInformationTransfer(RIMInformationTransfer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkRIMInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkRIMInformationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkRIMInformationTransferProtocolIEs(
    pub Vec<DownlinkRIMInformationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<DownlinkUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
    #[asn(key = 189)]
    Id_ExtendedPacketDelayBudget(ExtendedPacketDelayBudget),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Dynamic5QIDescriptorIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: Dynamic5QIDescriptorIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Dynamic5QIDescriptorIE_Extensions(pub Vec<Dynamic5QIDescriptorIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABInformationItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABInformationItemIE_Extensions(pub Vec<E_RABInformationItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct BIT_STRING_18(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct BIT_STRING_19(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct BIT_STRING_20(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct BIT_STRING_21(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EPS_TAIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EPS_TAIIE_Extensions(pub Vec<EPS_TAIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRA_CGIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRA_CGIIE_Extensions(pub Vec<EUTRA_CGIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EarlyStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDBroadcastEUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDBroadcastNR_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDBroadcastNR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDCancelledEUTRA_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDCancelledNR_ItemIE_Extensions(
    pub Vec<EmergencyAreaIDCancelledNR_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyFallbackIndicatorIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyFallbackIndicatorIE_Extensions(
    pub Vec<EmergencyFallbackIndicatorIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EndpointIPAddressAndPortIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EndpointIPAddressAndPortIE_Extensions(
    pub Vec<EndpointIPAddressAndPortIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ErrorIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ErrorIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ErrorIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ErrorIndicationProtocolIEs(pub Vec<ErrorIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EventL1LoggedMDTConfigIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EventL1LoggedMDTConfigIE_Extensions(pub Vec<EventL1LoggedMDTConfigIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_22(pub u8);
impl ENUMERATED_22 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EventTriggerchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEActivityBehaviourIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEActivityBehaviourIE_Extensions(
    pub Vec<ExpectedUEActivityBehaviourIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEBehaviourIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEBehaviourIE_Extensions(pub Vec<ExpectedUEBehaviourIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct INTEGER_23(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEMovingTrajectoryItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEMovingTrajectoryItemIE_Extensions(
    pub Vec<ExpectedUEMovingTrajectoryItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Extended_AMFNameIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Extended_AMFNameIE_Extensions(pub Vec<Extended_AMFNameIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Extended_RANNodeNameIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Extended_RANNodeNameIE_Extensions(pub Vec<Extended_RANNodeNameIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct BIT_STRING_24(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "8", sz_ub = "8")]
pub struct BIT_STRING_25(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExtendedRATRestrictionInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExtendedRATRestrictionInformationIE_Extensions(
    pub Vec<ExtendedRATRestrictionInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FailureIndicationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FailureIndicationIE_Extensions(pub Vec<FailureIndicationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FirstDLCountIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FirstDLCountIE_Extension(pub Vec<FirstDLCountIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FiveG_S_TMSIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FiveG_S_TMSIIE_Extensions(pub Vec<FiveG_S_TMSIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenAreaInformation_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenAreaInformation_ItemIE_Extensions(
    pub Vec<ForbiddenAreaInformation_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FromEUTRANtoNGRANIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FromEUTRANtoNGRANIE_Extensions(pub Vec<FromEUTRANtoNGRANIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FromNGRANtoEUTRANIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FromNGRANtoEUTRANIE_Extensions(pub Vec<FromNGRANtoEUTRANIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum GBR_QosInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 220)]
    Id_AlternativeQoSParaSetList(AlternativeQoSParaSetList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GBR_QosInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GBR_QosInformationIE_Extensions(pub Vec<GBR_QosInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "32")]
pub struct BIT_STRING_26(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GNB_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GTPTunnelIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GTPTunnelIE_Extensions(pub Vec<GTPTunnelIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GUAMIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GUAMIIE_Extensions(pub Vec<GUAMIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalENB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalENB_IDIE_Extensions(pub Vec<GlobalENB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalGNB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalGNB_IDIE_Extensions(pub Vec<GlobalGNB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalLine_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalLine_IDIE_Extensions(pub Vec<GlobalLine_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalN3IWF_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalN3IWF_IDIE_Extensions(pub Vec<GlobalN3IWF_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalNgENB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalNgENB_IDIE_Extensions(pub Vec<GlobalNgENB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum GlobalRANNodeIDchoice_ExtensionsValue {
    #[asn(key = 240)]
    Id_GlobalTNGF_ID(GlobalTNGF_ID),
    #[asn(key = 241)]
    Id_GlobalTWIF_ID(GlobalTWIF_ID),
    #[asn(key = 242)]
    Id_GlobalW_AGF_ID(GlobalW_AGF_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalRANNodeIDchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: GlobalRANNodeIDchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalTNGF_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalTNGF_IDIE_Extensions(pub Vec<GlobalTNGF_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalTWIF_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalTWIF_IDIE_Extensions(pub Vec<GlobalTWIF_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GlobalW_AGF_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GlobalW_AGF_IDIE_Extensions(pub Vec<GlobalW_AGF_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ENUMERATED_27(pub u8);
impl ENUMERATED_27 {
    pub const HO_TOO_EARLY: u8 = 0u8;
    pub const HO_TO_WRONG_CELL: u8 = 1u8;
    pub const INTERSYSTEM_PING_PONG: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct BIT_STRING_28(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HOReportIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HOReportIE_Extensions(pub Vec<HOReportIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelProtocolIEs(pub Vec<HandoverCancelProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelAcknowledgeProtocolIEs(
    pub Vec<HandoverCancelAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCommandProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 39)]
    Id_NASSecurityParametersFromNGRAN(NASSecurityParametersFromNGRAN),
    #[asn(key = 59)]
    Id_PDUSessionResourceHandoverList(PDUSessionResourceHandoverList),
    #[asn(key = 78)]
    Id_PDUSessionResourceToReleaseListHOCmd(PDUSessionResourceToReleaseListHOCmd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 106)]
    Id_TargetToSource_TransparentContainer(TargetToSource_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCommandProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCommandProtocolIEs(pub Vec<HandoverCommandProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverCommandTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 152)]
    Id_AdditionalDLForwardingUPTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 172)]
    Id_AdditionalULForwardingUPTNLInformation(UPTransportLayerInformationList),
    #[asn(key = 249)]
    Id_DataForwardingResponseERABList(DataForwardingResponseERABList),
    #[asn(key = 164)]
    Id_ULForwardingUP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverCommandTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverCommandTransferIE_Extensions(
    pub Vec<HandoverCommandTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 262)]
    Id_TargettoSource_Failure_TransparentContainer(TargettoSource_Failure_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverFailureProtocolIEs(pub Vec<HandoverFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverNotifyProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 269)]
    Id_NotifySourceNGRANNode(NotifySourceNGRANNode),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverNotifyProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverNotifyProtocolIEs(pub Vec<HandoverNotifyProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverPreparationFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 262)]
    Id_TargettoSource_Failure_TransparentContainer(TargettoSource_Failure_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverPreparationFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverPreparationFailureProtocolIEs(
    pub Vec<HandoverPreparationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverPreparationUnsuccessfulTransferIE_Extensions(
    pub Vec<HandoverPreparationUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 28)]
    Id_GUAMI(GUAMI),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 254)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 34)]
    Id_MaskedIMEISV(MaskedIMEISV),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 37)]
    Id_NASC(NAS_PDU),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 41)]
    Id_NewSecurityContextInd(NewSecurityContextInd),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 73)]
    Id_PDUSessionResourceSetupListHOReq(PDUSessionResourceSetupListHOReq),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 101)]
    Id_SourceToTarget_TransparentContainer(SourceToTarget_TransparentContainer),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestProtocolIEs(pub Vec<HandoverRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 53)]
    Id_PDUSessionResourceAdmittedList(PDUSessionResourceAdmittedList),
    #[asn(key = 56)]
    Id_PDUSessionResourceFailedToSetupListHOAck(PDUSessionResourceFailedToSetupListHOAck),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 106)]
    Id_TargetToSource_TransparentContainer(TargetToSource_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeProtocolIEs(
    pub Vec<HandoverRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 153)]
    Id_AdditionalDLUPTNLInformationForHOList(AdditionalDLUPTNLInformationForHOList),
    #[asn(key = 172)]
    Id_AdditionalULForwardingUPTNLInformation(UPTransportLayerInformationList),
    #[asn(key = 249)]
    Id_DataForwardingResponseERABList(DataForwardingResponseERABList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 164)]
    Id_ULForwardingUP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeTransferIE_Extensions(
    pub Vec<HandoverRequestAcknowledgeTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverRequiredProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 22)]
    Id_DirectForwardingPathAvailability(DirectForwardingPathAvailability),
    #[asn(key = 29)]
    Id_HandoverType(HandoverType),
    #[asn(key = 61)]
    Id_PDUSessionResourceListHORqd(PDUSessionResourceListHORqd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 101)]
    Id_SourceToTarget_TransparentContainer(SourceToTarget_TransparentContainer),
    #[asn(key = 105)]
    Id_TargetID(TargetID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequiredProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequiredProtocolIEs(pub Vec<HandoverRequiredProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRequiredTransferIE_Extensions(
    pub Vec<HandoverRequiredTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverResourceAllocationUnsuccessfulTransferIE_Extensions(
    pub Vec<HandoverResourceAllocationUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum HandoverSuccessProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverSuccessProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverSuccessProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverSuccessProtocolIEs(pub Vec<HandoverSuccessProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ImmediateMDTNrIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ImmediateMDTNrIE_Extensions(pub Vec<ImmediateMDTNrIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions(
    pub Vec<InfoOnRecommendedCellsAndRANNodesForPagingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 132)]
    Id_PDUSessionResourceFailedToSetupListCxtFail(PDUSessionResourceFailedToSetupListCxtFail),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupFailureProtocolIEs(
    pub Vec<InitialContextSetupFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 24)]
    Id_EmergencyFallbackIndicator(EmergencyFallbackIndicator),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 28)]
    Id_GUAMI(GUAMI),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 254)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 34)]
    Id_MaskedIMEISV(MaskedIMEISV),
    #[asn(key = 36)]
    Id_MobilityRestrictionList(MobilityRestrictionList),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 48)]
    Id_OldAMF(AMFName),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 71)]
    Id_PDUSessionResourceSetupListCxtReq(PDUSessionResourceSetupListCxtReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 238)]
    Id_RGLevelWirelineAccessCharacteristics(RGLevelWirelineAccessCharacteristics),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 94)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupRequestProtocolIEs(
    pub Vec<InitialContextSetupRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 55)]
    Id_PDUSessionResourceFailedToSetupListCxtRes(PDUSessionResourceFailedToSetupListCxtRes),
    #[asn(key = 72)]
    Id_PDUSessionResourceSetupListCxtRes(PDUSessionResourceSetupListCxtRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupResponseProtocolIEs(
    pub Vec<InitialContextSetupResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitialUEMessageProtocolIEs_EntryValue {
    #[asn(key = 3)]
    Id_AMFSetID(AMFSetID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 245)]
    Id_AuthenticatedIndication(AuthenticatedIndication),
    #[asn(key = 224)]
    Id_CEmodeBSupport_Indicator(CEmodeBSupport_Indicator),
    #[asn(key = 227)]
    Id_EDT_Session(EDT_Session),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 201)]
    Id_IABNodeIndication(IABNodeIndication),
    #[asn(key = 225)]
    Id_LTEM_Indication(LTEM_Indication),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 259)]
    Id_NPN_AccessInformation(NPN_AccessInformation),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 90)]
    Id_RRCEstablishmentCause(RRCEstablishmentCause),
    #[asn(key = 174)]
    Id_SelectedPLMNIdentity(PLMNIdentity),
    #[asn(key = 171)]
    Id_SourceToTarget_AMFInformationReroute(SourceToTarget_AMFInformationReroute),
    #[asn(key = 112)]
    Id_UEContextRequest(UEContextRequest),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialUEMessageProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialUEMessageProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialUEMessageProtocolIEs(pub Vec<InitialUEMessageProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum InitiatingMessageValue {
    #[asn(key = 64)]
    Id_AMFCPRelocationIndication(AMFCPRelocationIndication),
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdate),
    #[asn(key = 1)]
    Id_AMFStatusIndication(AMFStatusIndication),
    #[asn(key = 2)]
    Id_CellTrafficTrace(CellTrafficTrace),
    #[asn(key = 65)]
    Id_ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
    #[asn(key = 3)]
    Id_DeactivateTrace(DeactivateTrace),
    #[asn(key = 4)]
    Id_DownlinkNASTransport(DownlinkNASTransport),
    #[asn(key = 5)]
    Id_DownlinkNonUEAssociatedNRPPaTransport(DownlinkNonUEAssociatedNRPPaTransport),
    #[asn(key = 6)]
    Id_DownlinkRANConfigurationTransfer(DownlinkRANConfigurationTransfer),
    #[asn(key = 63)]
    Id_DownlinkRANEarlyStatusTransfer(DownlinkRANEarlyStatusTransfer),
    #[asn(key = 7)]
    Id_DownlinkRANStatusTransfer(DownlinkRANStatusTransfer),
    #[asn(key = 54)]
    Id_DownlinkRIMInformationTransfer(DownlinkRIMInformationTransfer),
    #[asn(key = 8)]
    Id_DownlinkUEAssociatedNRPPaTransport(DownlinkUEAssociatedNRPPaTransport),
    #[asn(key = 9)]
    Id_ErrorIndication(ErrorIndication),
    #[asn(key = 10)]
    Id_HandoverCancel(HandoverCancel),
    #[asn(key = 11)]
    Id_HandoverNotification(HandoverNotify),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverRequired),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverRequest),
    #[asn(key = 61)]
    Id_HandoverSuccess(HandoverSuccess),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupRequest),
    #[asn(key = 15)]
    Id_InitialUEMessage(InitialUEMessage),
    #[asn(key = 18)]
    Id_LocationReport(LocationReport),
    #[asn(key = 16)]
    Id_LocationReportingControl(LocationReportingControl),
    #[asn(key = 17)]
    Id_LocationReportingFailureIndication(LocationReportingFailureIndication),
    #[asn(key = 19)]
    Id_NASNonDeliveryIndication(NASNonDeliveryIndication),
    #[asn(key = 20)]
    Id_NGReset(NGReset),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupRequest),
    #[asn(key = 22)]
    Id_OverloadStart(OverloadStart),
    #[asn(key = 23)]
    Id_OverloadStop(OverloadStop),
    #[asn(key = 26)]
    Id_PDUSessionResourceModify(PDUSessionResourceModifyRequest),
    #[asn(key = 27)]
    Id_PDUSessionResourceModifyIndication(PDUSessionResourceModifyIndication),
    #[asn(key = 30)]
    Id_PDUSessionResourceNotify(PDUSessionResourceNotify),
    #[asn(key = 28)]
    Id_PDUSessionResourceRelease(PDUSessionResourceReleaseCommand),
    #[asn(key = 29)]
    Id_PDUSessionResourceSetup(PDUSessionResourceSetupRequest),
    #[asn(key = 32)]
    Id_PWSCancel(PWSCancelRequest),
    #[asn(key = 33)]
    Id_PWSFailureIndication(PWSFailureIndication),
    #[asn(key = 34)]
    Id_PWSRestartIndication(PWSRestartIndication),
    #[asn(key = 24)]
    Id_Paging(Paging),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequest),
    #[asn(key = 31)]
    Id_PrivateMessage(PrivateMessage),
    #[asn(key = 57)]
    Id_RANCPRelocationIndication(RANCPRelocationIndication),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdate),
    #[asn(key = 37)]
    Id_RRCInactiveTransitionReport(RRCInactiveTransitionReport),
    #[asn(key = 36)]
    Id_RerouteNASRequest(RerouteNASRequest),
    #[asn(key = 55)]
    Id_RetrieveUEInformation(RetrieveUEInformation),
    #[asn(key = 52)]
    Id_SecondaryRATDataUsageReport(SecondaryRATDataUsageReport),
    #[asn(key = 38)]
    Id_TraceFailureIndication(TraceFailureIndication),
    #[asn(key = 39)]
    Id_TraceStart(TraceStart),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationRequest),
    #[asn(key = 41)]
    Id_UEContextRelease(UEContextReleaseCommand),
    #[asn(key = 42)]
    Id_UEContextReleaseRequest(UEContextReleaseRequest),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeRequest),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendRequest),
    #[asn(key = 56)]
    Id_UEInformationTransfer(UEInformationTransfer),
    #[asn(key = 43)]
    Id_UERadioCapabilityCheck(UERadioCapabilityCheckRequest),
    #[asn(key = 60)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingRequest),
    #[asn(key = 44)]
    Id_UERadioCapabilityInfoIndication(UERadioCapabilityInfoIndication),
    #[asn(key = 45)]
    Id_UETNLABindingRelease(UETNLABindingReleaseRequest),
    #[asn(key = 46)]
    Id_UplinkNASTransport(UplinkNASTransport),
    #[asn(key = 47)]
    Id_UplinkNonUEAssociatedNRPPaTransport(UplinkNonUEAssociatedNRPPaTransport),
    #[asn(key = 48)]
    Id_UplinkRANConfigurationTransfer(UplinkRANConfigurationTransfer),
    #[asn(key = 62)]
    Id_UplinkRANEarlyStatusTransfer(UplinkRANEarlyStatusTransfer),
    #[asn(key = 49)]
    Id_UplinkRANStatusTransfer(UplinkRANStatusTransfer),
    #[asn(key = 53)]
    Id_UplinkRIMInformationTransfer(UplinkRIMInformationTransfer),
    #[asn(key = 50)]
    Id_UplinkUEAssociatedNRPPaTransport(UplinkUEAssociatedNRPPaTransport),
    #[asn(key = 51)]
    Id_WriteReplaceWarning(WriteReplaceWarningRequest),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemFailureIndicationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemFailureIndicationIE_Extensions(
    pub Vec<InterSystemFailureIndicationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemHOReportIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemHOReportIE_Extensions(pub Vec<InterSystemHOReportIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemHandoverReportTypechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONConfigurationTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONConfigurationTransferIE_Extensions(
    pub Vec<IntersystemSONConfigurationTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONInformationReportchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONNGRANnodeIDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONNGRANnodeIDIE_Extensions(
    pub Vec<IntersystemSONNGRANnodeIDIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONTransferTypechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemSONeNBIDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemSONeNBIDIE_Extensions(pub Vec<IntersystemSONeNBIDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_29(pub u8);
impl ENUMERATED_29 {
    pub const TRUE: u8 = 0u8;
    pub const FALSE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemUnnecessaryHOIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemUnnecessaryHOIE_Extensions(
    pub Vec<IntersystemUnnecessaryHOIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LAIIE_Extensions(pub Vec<LAIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LTEUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<LTEUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LTEV2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LTEV2XServicesAuthorizedIE_Extensions(
    pub Vec<LTEV2XServicesAuthorizedIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedCellInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedCellItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedCellItemIE_Extensions(pub Vec<LastVisitedCellItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedNGRANCellInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedNGRANCellInformationIE_Extensions(
    pub Vec<LastVisitedNGRANCellInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 116)]
    Id_UEPresenceInAreaOfInterestList(UEPresenceInAreaOfInterestList),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportProtocolIEs(pub Vec<LocationReportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingControlProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 33)]
    Id_LocationReportingRequestType(LocationReportingRequestType),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingControlProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingControlProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingControlProtocolIEs(pub Vec<LocationReportingControlProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingFailureIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingFailureIndicationProtocolIEs(
    pub Vec<LocationReportingFailureIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum LocationReportingRequestTypeIE_Extensions_EntryExtensionValue {
    #[asn(key = 170)]
    Id_LocationReportingAdditionalInfo(LocationReportingAdditionalInfo),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingRequestTypeIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LocationReportingRequestTypeIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LocationReportingRequestTypeIE_Extensions(
    pub Vec<LocationReportingRequestTypeIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTNrIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMDTNrIE_Extensions(pub Vec<LoggedMDTNrIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "NULL")]
pub struct NULL_30;

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTTriggerchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ConfigurationIE_Extensions(pub Vec<M1ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1PeriodicReportingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1PeriodicReportingIE_Extensions(pub Vec<M1PeriodicReportingIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdEventA2IE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ThresholdEventA2IE_Extensions(pub Vec<M1ThresholdEventA2IE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdTypechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M4ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M4ConfigurationIE_Extensions(pub Vec<M4ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M5ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M5ConfigurationIE_Extensions(pub Vec<M5ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M6ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M6ConfigurationIE_Extensions(pub Vec<M6ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M7ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M7ConfigurationIE_Extensions(pub Vec<M7ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_ConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_ConfigurationIE_Extensions(pub Vec<MDT_ConfigurationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Configuration_EUTRAIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Configuration_EUTRAIE_Extensions(
    pub Vec<MDT_Configuration_EUTRAIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Configuration_NRIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Configuration_NRIE_Extensions(pub Vec<MDT_Configuration_NRIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_Location_InfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_Location_InfoIE_Extensions(pub Vec<MDT_Location_InfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDTModeNrchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MeasurementThresholdL1LoggedMDTchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum MobilityRestrictionListIE_Extensions_EntryExtensionValue {
    #[asn(key = 160)]
    Id_CNTypeRestrictionsForEquivalent(CNTypeRestrictionsForEquivalent),
    #[asn(key = 161)]
    Id_CNTypeRestrictionsForServing(CNTypeRestrictionsForServing),
    #[asn(key = 150)]
    Id_LastEUTRAN_PLMNIdentity(PLMNIdentity),
    #[asn(key = 261)]
    Id_NPN_MobilityInformation(NPN_MobilityInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MobilityRestrictionListIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: MobilityRestrictionListIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MobilityRestrictionListIE_Extensions(
    pub Vec<MobilityRestrictionListIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct BIT_STRING_31(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct N3IWF_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NASNonDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASNonDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASNonDeliveryIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASNonDeliveryIndicationProtocolIEs(pub Vec<NASNonDeliveryIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NB_IoT_Paging_eDRXInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NB_IoT_Paging_eDRXInfoIE_Extensions(pub Vec<NB_IoT_Paging_eDRXInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGRAN_CGIchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NGRAN_TNLAssociationToRemoveItemIE_Extensions(
    pub Vec<NGRAN_TNLAssociationToRemoveItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NGResetProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 88)]
    Id_ResetType(ResetType),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGResetProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGResetProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGResetProtocolIEs(pub Vec<NGResetProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NGResetAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_UE_associatedLogicalNG_connectionList(UE_associatedLogicalNG_connectionList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGResetAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGResetAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGResetAcknowledgeProtocolIEs(pub Vec<NGResetAcknowledgeProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupFailureProtocolIEs(pub Vec<NGSetupFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 273)]
    Id_Extended_RANNodeName(Extended_RANNodeName),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 204)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 82)]
    Id_RANNodeName(RANNodeName),
    #[asn(key = 102)]
    Id_SupportedTAList(SupportedTAList),
    #[asn(key = 147)]
    Id_UERetentionInformation(UERetentionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupRequestProtocolIEs(pub Vec<NGSetupRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NGSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 1)]
    Id_AMFName(AMFName),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 274)]
    Id_Extended_AMFName(Extended_AMFName),
    #[asn(key = 200)]
    Id_IAB_Supported(IAB_Supported),
    #[asn(key = 80)]
    Id_PLMNSupportList(PLMNSupportList),
    #[asn(key = 86)]
    Id_RelativeAMFCapacity(RelativeAMFCapacity),
    #[asn(key = 96)]
    Id_ServedGUAMIList(ServedGUAMIList),
    #[asn(key = 147)]
    Id_UERetentionInformation(UERetentionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NGSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NGSetupResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NGSetupResponseProtocolIEs(pub Vec<NGSetupResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_AccessInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_MobilityInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_PagingAssistanceInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NPN_Supportchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NR_CGIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIIE_Extensions(pub Vec<NR_CGIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRFrequencyBandItemIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRFrequencyBandItemIE_Extension(pub Vec<NRFrequencyBandItemIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRFrequencyInfoIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRFrequencyInfoIE_Extension(pub Vec<NRFrequencyInfoIE_Extension_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRV2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRV2XServicesAuthorizedIE_Extensions(
    pub Vec<NRV2XServicesAuthorizedIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct BIT_STRING_32(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct BIT_STRING_33(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct BIT_STRING_34(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NgENB_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue {
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NonDynamic5QIDescriptorIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: NonDynamic5QIDescriptorIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NonDynamic5QIDescriptorIE_Extensions(
    pub Vec<NonDynamic5QIDescriptorIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadResponsechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum OverloadStartProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_AMFOverloadResponse(OverloadResponse),
    #[asn(key = 9)]
    Id_AMFTrafficLoadReductionIndication(TrafficLoadReductionIndication),
    #[asn(key = 49)]
    Id_OverloadStartNSSAIList(OverloadStartNSSAIList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStartProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStartProtocolIEs(pub Vec<OverloadStartProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartNSSAIItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct OverloadStartNSSAIItemIE_Extensions(pub Vec<OverloadStartNSSAIItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStopProtocolIEs_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStopProtocolIEs(pub Vec<OverloadStopProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5FlowBitRatesIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5FlowBitRatesIE_Extensions(pub Vec<PC5FlowBitRatesIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSFlowItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSFlowItemIE_Extensions(pub Vec<PC5QoSFlowItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSParametersIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSParametersIE_Extensions(pub Vec<PC5QoSParametersIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionAggregateMaximumBitRateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionAggregateMaximumBitRateIE_Extensions(
    pub Vec<PDUSessionAggregateMaximumBitRateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_35(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceAdmittedItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceAdmittedItemIE_Extensions(
    pub Vec<PDUSessionResourceAdmittedItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_36(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToModifyItemModCfmIE_Extensions(
    pub Vec<PDUSessionResourceFailedToModifyItemModCfmIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_37(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToModifyItemModResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToModifyItemModResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToResumeItemRESReqIE_Extensions(
    pub Vec<PDUSessionResourceFailedToResumeItemRESReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToResumeItemRESResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToResumeItemRESResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_38(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtFailIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_39(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemCxtResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemCxtResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_40(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemHOAckIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemHOAckIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_41(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemPSReqIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemPSReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_42(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceFailedToSetupItemSUResIE_Extensions(
    pub Vec<PDUSessionResourceFailedToSetupItemSUResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_43(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceHandoverItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceHandoverItemIE_Extensions(
    pub Vec<PDUSessionResourceHandoverItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceInformationItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceInformationItemIE_Extensions(
    pub Vec<PDUSessionResourceInformationItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemCxtRelCplIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceItemCxtRelCplIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemCxtRelCplIE_Extensions(
    pub Vec<PDUSessionResourceItemCxtRelCplIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemCxtRelReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemCxtRelReqIE_Extensions(
    pub Vec<PDUSessionResourceItemCxtRelReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_44(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceItemHORqdIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceItemHORqdIE_Extensions(
    pub Vec<PDUSessionResourceItemHORqdIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyConfirmProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 131)]
    Id_PDUSessionResourceFailedToModifyListModCfm(PDUSessionResourceFailedToModifyListModCfm),
    #[asn(key = 62)]
    Id_PDUSessionResourceModifyListModCfm(PDUSessionResourceModifyListModCfm),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyConfirmProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyConfirmProtocolIEs(
    pub Vec<PDUSessionResourceModifyConfirmProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyConfirmTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyConfirmTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyConfirmTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 63)]
    Id_PDUSessionResourceModifyListModInd(PDUSessionResourceModifyListModInd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationProtocolIEs(
    pub Vec<PDUSessionResourceModifyIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 193)]
    Id_RedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformation),
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
    #[asn(key = 156)]
    Id_SecurityResult(SecurityResult),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        PDUSessionResourceModifyIndicationTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyIndicationTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyIndicationUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_45(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModCfmIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModCfmIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModCfmIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_46(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModIndIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModIndIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModIndIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_47(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyItemModReqIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModReqIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_48(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyItemModResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyItemModResIE_Extensions(
    pub Vec<PDUSessionResourceModifyItemModResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 64)]
    Id_PDUSessionResourceModifyListModReq(PDUSessionResourceModifyListModReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyRequestProtocolIEs(
    pub Vec<PDUSessionResourceModifyRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue {
    #[asn(key = 186)]
    Id_AdditionalRedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 126)]
    Id_AdditionalUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 166)]
    Id_CommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 129)]
    Id_NetworkInstance(NetworkInstance),
    #[asn(key = 130)]
    Id_PDUSessionAggregateMaximumBitRate(PDUSessionAggregateMaximumBitRate),
    #[asn(key = 135)]
    Id_QosFlowAddOrModifyRequestList(QosFlowAddOrModifyRequestList),
    #[asn(key = 137)]
    Id_QosFlowToReleaseList(QosFlowListWithCause),
    #[asn(key = 190)]
    Id_RedundantCommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 138)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 140)]
    Id_UL_NGU_UP_TNLModifyList(UL_NGU_UP_TNLModifyList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyRequestTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyRequestTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyRequestTransferProtocolIEs(
    pub Vec<PDUSessionResourceModifyRequestTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 54)]
    Id_PDUSessionResourceFailedToModifyListModRes(PDUSessionResourceFailedToModifyListModRes),
    #[asn(key = 65)]
    Id_PDUSessionResourceModifyListModRes(PDUSessionResourceModifyListModRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceModifyResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyResponseProtocolIEs(
    pub Vec<PDUSessionResourceModifyResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 154)]
    Id_AdditionalNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceModifyResponseTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyResponseTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceModifyUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 66)]
    Id_PDUSessionResourceNotifyList(PDUSessionResourceNotifyList),
    #[asn(key = 67)]
    Id_PDUSessionResourceReleasedListNot(PDUSessionResourceReleasedListNot),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceNotifyProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyProtocolIEs(pub Vec<PDUSessionResourceNotifyProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_49(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyItemIE_Extensions(
    pub Vec<PDUSessionResourceNotifyItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceNotifyReleasedTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyReleasedTransferIE_Extensions(
    pub Vec<PDUSessionResourceNotifyReleasedTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 278)]
    Id_QosFlowFeedbackList(QosFlowFeedbackList),
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceNotifyTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceNotifyTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceNotifyTransferIE_Extensions(
    pub Vec<PDUSessionResourceNotifyTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 79)]
    Id_PDUSessionResourceToReleaseListRelCmd(PDUSessionResourceToReleaseListRelCmd),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceReleaseCommandProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseCommandProtocolIEs(
    pub Vec<PDUSessionResourceReleaseCommandProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseCommandTransferIE_Extensions(
    pub Vec<PDUSessionResourceReleaseCommandTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 70)]
    Id_PDUSessionResourceReleasedListRelRes(PDUSessionResourceReleasedListRelRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceReleaseResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseResponseProtocolIEs(
    pub Vec<PDUSessionResourceReleaseResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 144)]
    Id_SecondaryRATUsageInformation(SecondaryRATUsageInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceReleaseResponseTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleaseResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceReleaseResponseTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_50(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemNotIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemNotIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemNotIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_51(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemPSAckIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemPSAckIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_52(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemPSFailIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemPSFailIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_53(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceReleasedItemRelResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceReleasedItemRelResIE_Extensions(
    pub Vec<PDUSessionResourceReleasedItemRelResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_54(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceResumeItemRESReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceResumeItemRESReqIE_Extensions(
    pub Vec<PDUSessionResourceResumeItemRESReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_55(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceResumeItemRESResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceResumeItemRESResIE_Extensions(
    pub Vec<PDUSessionResourceResumeItemRESResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_56(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSecondaryRATUsageItemIE_Extensions(
    pub Vec<PDUSessionResourceSecondaryRATUsageItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_57(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemCxtReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemCxtReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_58(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemCxtResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemCxtResIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemCxtResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_59(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemHOReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemHOReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemHOReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_60(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemSUReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemSUReqIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemSUReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_61(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupItemSUResIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupItemSUResIE_Extensions(
    pub Vec<PDUSessionResourceSetupItemSUResIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 74)]
    Id_PDUSessionResourceSetupListSUReq(PDUSessionResourceSetupListSUReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupRequestProtocolIEs(
    pub Vec<PDUSessionResourceSetupRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue {
    #[asn(key = 186)]
    Id_AdditionalRedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 126)]
    Id_AdditionalUL_NGU_UP_TNLInformation(UPTransportLayerInformationList),
    #[asn(key = 166)]
    Id_CommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 127)]
    Id_DataForwardingNotPossible(DataForwardingNotPossible),
    #[asn(key = 22)]
    Id_DirectForwardingPathAvailability(DirectForwardingPathAvailability),
    #[asn(key = 129)]
    Id_NetworkInstance(NetworkInstance),
    #[asn(key = 130)]
    Id_PDUSessionAggregateMaximumBitRate(PDUSessionAggregateMaximumBitRate),
    #[asn(key = 134)]
    Id_PDUSessionType(PDUSessionType),
    #[asn(key = 136)]
    Id_QosFlowSetupRequestList(QosFlowSetupRequestList),
    #[asn(key = 190)]
    Id_RedundantCommonNetworkInstance(CommonNetworkInstance),
    #[asn(key = 197)]
    Id_RedundantPDUSessionInformation(RedundantPDUSessionInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 138)]
    Id_SecurityIndication(SecurityIndication),
    #[asn(key = 139)]
    Id_UL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupRequestTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupRequestTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupRequestTransferProtocolIEs(
    pub Vec<PDUSessionResourceSetupRequestTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 58)]
    Id_PDUSessionResourceFailedToSetupListSURes(PDUSessionResourceFailedToSetupListSURes),
    #[asn(key = 75)]
    Id_PDUSessionResourceSetupListSURes(PDUSessionResourceSetupListSURes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PDUSessionResourceSetupResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupResponseProtocolIEs(
    pub Vec<PDUSessionResourceSetupResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 193)]
    Id_RedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupResponseTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PDUSessionResourceSetupResponseTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupResponseTransferIE_Extensions(
    pub Vec<PDUSessionResourceSetupResponseTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions(
    pub Vec<PDUSessionResourceSetupUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_62(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSuspendItemSUSReqIE_Extensions(
    pub Vec<PDUSessionResourceSuspendItemSUSReqIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_63(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceSwitchedItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceSwitchedItemIE_Extensions(
    pub Vec<PDUSessionResourceSwitchedItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_64(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToBeSwitchedDLItemIE_Extensions(
    pub Vec<PDUSessionResourceToBeSwitchedDLItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_65(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToReleaseItemHOCmdIE_Extensions(
    pub Vec<PDUSessionResourceToReleaseItemHOCmdIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING")]
pub struct OCTET_STRING_66(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionResourceToReleaseItemRelCmdIE_Extensions(
    pub Vec<PDUSessionResourceToReleaseItemRelCmdIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_67(pub u8);
impl ENUMERATED_67 {
    pub const NR: u8 = 0u8;
    pub const EUTRA: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PDUSessionUsageReportIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PDUSessionUsageReportIE_Extensions(pub Vec<PDUSessionUsageReportIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PLMNSupportItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 270)]
    Id_ExtendedSliceSupportList(ExtendedSliceSupportList),
    #[asn(key = 258)]
    Id_NPN_Support(NPN_Support),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMNSupportItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PLMNSupportItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PLMNSupportItemIE_Extensions(pub Vec<PLMNSupportItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PNI_NPN_MobilityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PNI_NPN_MobilityInformationIE_Extensions(
    pub Vec<PNI_NPN_MobilityInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PWSCancelRequestProtocolIEs_EntryValue {
    #[asn(key = 14)]
    Id_CancelAllWarningMessages(CancelAllWarningMessages),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 122)]
    Id_WarningAreaList(WarningAreaList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSCancelRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSCancelRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSCancelRequestProtocolIEs(pub Vec<PWSCancelRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PWSCancelResponseProtocolIEs_EntryValue {
    #[asn(key = 12)]
    Id_BroadcastCancelledAreaList(BroadcastCancelledAreaList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSCancelResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSCancelResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSCancelResponseProtocolIEs(pub Vec<PWSCancelResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailedCellIDListchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PWSFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 81)]
    Id_PWSFailedCellIDList(PWSFailedCellIDList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSFailureIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSFailureIndicationProtocolIEs(pub Vec<PWSFailureIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PWSRestartIndicationProtocolIEs_EntryValue {
    #[asn(key = 16)]
    Id_CellIDListForRestart(CellIDListForRestart),
    #[asn(key = 23)]
    Id_EmergencyAreaIDListForRestart(EmergencyAreaIDListForRestart),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 104)]
    Id_TAIListForRestart(TAIListForRestart),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSRestartIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSRestartIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSRestartIndicationProtocolIEs(pub Vec<PWSRestartIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct INTEGER_68(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "9", extensible = true)]
pub struct INTEGER_69(pub u8);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PacketErrorRateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PacketErrorRateIE_Extensions(pub Vec<PacketErrorRateIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PagingProtocolIEs_EntryValue {
    #[asn(key = 11)]
    Id_AssistanceDataForPaging(AssistanceDataForPaging),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 203)]
    Id_NB_IoT_Paging_eDRXInfo(NB_IoT_Paging_eDRXInfo),
    #[asn(key = 202)]
    Id_NB_IoT_PagingDRX(NB_IoT_PagingDRX),
    #[asn(key = 50)]
    Id_PagingDRX(PagingDRX),
    #[asn(key = 51)]
    Id_PagingOrigin(PagingOrigin),
    #[asn(key = 52)]
    Id_PagingPriority(PagingPriority),
    #[asn(key = 223)]
    Id_PagingeDRXInformation(PagingeDRXInformation),
    #[asn(key = 103)]
    Id_TAIListForPaging(TAIListForPaging),
    #[asn(key = 115)]
    Id_UEPagingIdentity(UEPagingIdentity),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 208)]
    Id_WUS_Assistance_Information(WUS_Assistance_Information),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PagingProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PagingProtocolIEs(pub Vec<PagingProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAssisDataforCEcapabUEIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAssisDataforCEcapabUEIE_Extensions(
    pub Vec<PagingAssisDataforCEcapabUEIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAttemptInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAttemptInformationIE_Extensions(
    pub Vec<PagingAttemptInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingeDRXInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingeDRXInformationIE_Extensions(pub Vec<PagingeDRXInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestProtocolIEs_EntryValue {
    #[asn(key = 57)]
    Id_PDUSessionResourceFailedToSetupListPSReq(PDUSessionResourceFailedToSetupListPSReq),
    #[asn(key = 76)]
    Id_PDUSessionResourceToBeSwitchedDLList(PDUSessionResourceToBeSwitchedDLList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 237)]
    Id_RRC_Resume_Cause(RRCEstablishmentCause),
    #[asn(key = 100)]
    Id_SourceAMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestProtocolIEs(pub Vec<PathSwitchRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 222)]
    Id_CEmodeBrestricted(CEmodeBrestricted),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 205)]
    Id_Enhanced_CoverageRestriction(Enhanced_CoverageRestriction),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 41)]
    Id_NewSecurityContextInd(NewSecurityContextInd),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 68)]
    Id_PDUSessionResourceReleasedListPSAck(PDUSessionResourceReleasedListPSAck),
    #[asn(key = 77)]
    Id_PDUSessionResourceSwitchedList(PDUSessionResourceSwitchedList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 146)]
    Id_RedirectionVoiceFallback(RedirectionVoiceFallback),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 234)]
    Id_UE_UP_CIoT_Support(UE_UP_CIoT_Support),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs(
    pub Vec<PathSwitchRequestAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 154)]
    Id_AdditionalNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 185)]
    Id_AdditionalRedundantNGU_UP_TNLInformation(UPTransportLayerInformationPairList),
    #[asn(key = 277)]
    Id_QosFlowParametersList(QosFlowParametersList),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PathSwitchRequestAcknowledgeTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeTransferIE_Extensions(
    pub Vec<PathSwitchRequestAcknowledgeTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 69)]
    Id_PDUSessionResourceReleasedListPSFail(PDUSessionResourceReleasedListPSFail),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestFailureProtocolIEs(pub Vec<PathSwitchRequestFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestSetupFailedTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestSetupFailedTransferIE_Extensions(
    pub Vec<PathSwitchRequestSetupFailedTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 155)]
    Id_AdditionalDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 184)]
    Id_AdditionalRedundantDLQosFlowPerTNLInformation(QosFlowPerTNLInformationList),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 191)]
    Id_RedundantDL_NGU_TNLInformationReused(DL_NGU_TNLInformationReused),
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 198)]
    Id_UsedRSNInformation(RedundantPDUSessionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: PathSwitchRequestTransferIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestTransferIE_Extensions(
    pub Vec<PathSwitchRequestTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestUnsuccessfulTransferIE_Extensions(
    pub Vec<PathSwitchRequestUnsuccessfulTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct INTEGER_70(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OBJECT-IDENTIFIER")]
pub struct OBJECT_IDENTIFIER_71;

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PrivateMessagePrivateIEs_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PrivateMessagePrivateIEs(pub Vec<PrivateMessagePrivateIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProcedureStageChoicechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_72(pub u8);
impl ENUMERATED_72 {
    pub const NR: u8 = 0u8;
    pub const EUTRA: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QoSFlowsUsageReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QoSFlowsUsageReport_ItemIE_Extensions(
    pub Vec<QoSFlowsUsageReport_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosCharacteristicschoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAcceptedItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAcceptedItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAcceptedItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAcceptedItemIE_Extensions(pub Vec<QosFlowAcceptedItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 194)]
    Id_RedundantQosFlowIndicator(RedundantQosFlowIndicator),
    #[asn(key = 196)]
    Id_TSCTrafficCharacteristics(TSCTrafficCharacteristics),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAddOrModifyRequestItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAddOrModifyRequestItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAddOrModifyRequestItemIE_Extensions(
    pub Vec<QosFlowAddOrModifyRequestItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowAddOrModifyResponseItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowAddOrModifyResponseItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowAddOrModifyResponseItemIE_Extensions(
    pub Vec<QosFlowAddOrModifyResponseItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowFeedbackItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowFeedbackItemIE_Extensions(pub Vec<QosFlowFeedbackItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowInformationItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 163)]
    Id_ULForwarding(ULForwarding),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowInformationItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowInformationItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowInformationItemIE_Extensions(pub Vec<QosFlowInformationItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetIndex),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowItemWithDataForwardingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowItemWithDataForwardingIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowItemWithDataForwardingIE_Extensions(
    pub Vec<QosFlowItemWithDataForwardingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue {
    #[asn(key = 276)]
    Id_QosMonitoringReportingFrequency(QosMonitoringReportingFrequency),
    #[asn(key = 181)]
    Id_QosMonitoringRequest(QosMonitoringRequest),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowLevelQosParametersIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowLevelQosParametersIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowLevelQosParametersIE_Extensions(
    pub Vec<QosFlowLevelQosParametersIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowModifyConfirmItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowModifyConfirmItemIE_Extensions(
    pub Vec<QosFlowModifyConfirmItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowNotifyItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 221)]
    Id_CurrentQoSParaSetIndex(AlternativeQoSParaSetNotifyIndex),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowNotifyItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowNotifyItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowNotifyItemIE_Extensions(pub Vec<QosFlowNotifyItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowParametersItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 279)]
    Id_BurstArrivalTimeDownlink(BurstArrivalTime),
    #[asn(key = 187)]
    Id_CNPacketDelayBudgetDL(ExtendedPacketDelayBudget),
    #[asn(key = 188)]
    Id_CNPacketDelayBudgetUL(ExtendedPacketDelayBudget),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowParametersItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowParametersItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowParametersItemIE_Extensions(pub Vec<QosFlowParametersItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowPerTNLInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowPerTNLInformationIE_Extensions(
    pub Vec<QosFlowPerTNLInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowPerTNLInformationItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowPerTNLInformationItemIE_Extensions(
    pub Vec<QosFlowPerTNLInformationItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 194)]
    Id_RedundantQosFlowIndicator(RedundantQosFlowIndicator),
    #[asn(key = 196)]
    Id_TSCTrafficCharacteristics(TSCTrafficCharacteristics),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowSetupRequestItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: QosFlowSetupRequestItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowSetupRequestItemIE_Extensions(
    pub Vec<QosFlowSetupRequestItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowToBeForwardedItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowToBeForwardedItemIE_Extensions(
    pub Vec<QosFlowToBeForwardedItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct QosFlowWithCauseItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct QosFlowWithCauseItemIE_Extensions(pub Vec<QosFlowWithCauseItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RANCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 25)]
    Id_EUTRA_CGI(EUTRA_CGI),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 213)]
    Id_TAI(TAI),
    #[asn(key = 211)]
    Id_UL_CP_SecurityInformation(UL_CP_SecurityInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANCPRelocationIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANCPRelocationIndicationProtocolIEs(
    pub Vec<RANCPRelocationIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 21)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 273)]
    Id_Extended_RANNodeName(Extended_RANNodeName),
    #[asn(key = 27)]
    Id_GlobalRANNodeID(GlobalRANNodeID),
    #[asn(key = 204)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 167)]
    Id_NGRAN_TNLAssociationToRemoveList(NGRAN_TNLAssociationToRemoveList),
    #[asn(key = 82)]
    Id_RANNodeName(RANNodeName),
    #[asn(key = 102)]
    Id_SupportedTAList(SupportedTAList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateProtocolIEs(pub Vec<RANConfigurationUpdateProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<RANConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RANConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 107)]
    Id_TimeToWait(TimeToWait),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RANConfigurationUpdateFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RANConfigurationUpdateFailureProtocolIEs(
    pub Vec<RANConfigurationUpdateFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RANStatusTransfer_TransparentContainerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RANStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<RANStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RATRestrictions_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 180)]
    Id_ExtendedRATRestrictionInformation(ExtendedRATRestrictionInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RATRestrictions_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RATRestrictions_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RATRestrictions_ItemIE_Extensions(pub Vec<RATRestrictions_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_73(pub u8);
impl ENUMERATED_73 {
    pub const RS_DETECTED: u8 = 0u8;
    pub const RS_DISAPPEARED: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMInformationIE_Extensions(pub Vec<RIMInformationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMInformationTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMInformationTransferIE_Extensions(pub Vec<RIMInformationTransferIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RRCInactiveTransitionReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 92)]
    Id_RRCState(RRCState),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RRCInactiveTransitionReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RRCInactiveTransitionReportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RRCInactiveTransitionReportProtocolIEs(
    pub Vec<RRCInactiveTransitionReportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct INTEGER_74(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellItemIE_Extensions(pub Vec<RecommendedCellItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellsForPagingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellsForPagingIE_Extensions(
    pub Vec<RecommendedCellsForPagingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedRANNodeItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedRANNodeItemIE_Extensions(pub Vec<RecommendedRANNodeItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedRANNodesForPagingIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedRANNodesForPagingIE_Extensions(
    pub Vec<RecommendedRANNodesForPagingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RedundantPDUSessionInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RedundantPDUSessionInformationIE_Extensions(
    pub Vec<RedundantPDUSessionInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RerouteNASRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 3)]
    Id_AMFSetID(AMFSetID),
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 171)]
    Id_SourceToTarget_AMFInformationReroute(SourceToTarget_AMFInformationReroute),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RerouteNASRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RerouteNASRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RerouteNASRequestProtocolIEs(pub Vec<RerouteNASRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetTypechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum RetrieveUEInformationProtocolIEs_EntryValue {
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEInformationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEInformationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEInformationProtocolIEs(pub Vec<RetrieveUEInformationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S_NSSAIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct S_NSSAIIE_Extensions(pub Vec<S_NSSAIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SNPN_MobilityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SNPN_MobilityInformationIE_Extensions(
    pub Vec<SNPN_MobilityInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONConfigurationTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONConfigurationTransferIE_Extensions(
    pub Vec<SONConfigurationTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SONInformationchoice_ExtensionsValue {
    #[asn(key = 252)]
    Id_SONInformationReport(SONInformationReport),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SONInformationchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReplyIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONInformationReplyIE_Extensions(pub Vec<SONInformationReplyIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReportchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct BIT_STRING_75(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct INTEGER_76(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct INTEGER_77(pub u32);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ScheduledCommunicationTimeIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ScheduledCommunicationTimeIE_Extensions(
    pub Vec<ScheduledCommunicationTimeIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 143)]
    Id_HandoverFlag(HandoverFlag),
    #[asn(key = 142)]
    Id_PDUSessionResourceSecondaryRATUsageList(PDUSessionResourceSecondaryRATUsageList),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportProtocolIEs(
    pub Vec<SecondaryRATDataUsageReportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportTransferIE_Extensions(
    pub Vec<SecondaryRATDataUsageReportTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATUsageInformationIE_Extension_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATUsageInformationIE_Extension(
    pub Vec<SecondaryRATUsageInformationIE_Extension_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityContextIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityContextIE_Extensions(pub Vec<SecurityContextIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SecurityIndicationIE_Extensions_EntryExtensionValue {
    #[asn(key = 151)]
    Id_MaximumIntegrityProtectedDataRate_DL(MaximumIntegrityProtectedDataRate),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityIndicationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SecurityIndicationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityIndicationIE_Extensions(pub Vec<SecurityIndicationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityResultIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityResultIE_Extensions(pub Vec<SecurityResultIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasConfigNameItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasConfigNameItemIE_Extensions(
    pub Vec<SensorMeasConfigNameItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SensorMeasurementConfigurationIE_Extensions(
    pub Vec<SensorMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_78(pub u8);
impl ENUMERATED_78 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_79(pub u8);
impl ENUMERATED_79 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_80(pub u8);
impl ENUMERATED_80 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SensorNameConfigchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum ServedGUAMIItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 176)]
    Id_GUAMIType(GUAMIType),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedGUAMIItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ServedGUAMIItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGUAMIItemIE_Extensions(pub Vec<ServedGUAMIItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServiceAreaInformation_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServiceAreaInformation_ItemIE_Extensions(
    pub Vec<ServiceAreaInformation_ItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SliceOverloadItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SliceOverloadItemIE_Extensions(pub Vec<SliceOverloadItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SliceSupportItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SliceSupportItemIE_Extensions(pub Vec<SliceSupportItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 182)]
    Id_SgNB_UE_X2AP_ID(SgNB_UE_X2AP_ID),
    #[asn(key = 253)]
    Id_UEHistoryInformationFromTheUE(UEHistoryInformationFromTheUE),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions(
    pub Vec<SourceNGRANNode_ToTargetNGRANNode_TransparentContainerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceRANNodeIDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceRANNodeIDIE_Extensions(pub Vec<SourceRANNodeIDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceToTarget_AMFInformationRerouteIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceToTarget_AMFInformationRerouteIE_Extensions(
    pub Vec<SourceToTarget_AMFInformationRerouteIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SuccessfulOutcomeValue {
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdateAcknowledge),
    #[asn(key = 10)]
    Id_HandoverCancel(HandoverCancelAcknowledge),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverCommand),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverRequestAcknowledge),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupResponse),
    #[asn(key = 20)]
    Id_NGReset(NGResetAcknowledge),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupResponse),
    #[asn(key = 26)]
    Id_PDUSessionResourceModify(PDUSessionResourceModifyResponse),
    #[asn(key = 27)]
    Id_PDUSessionResourceModifyIndication(PDUSessionResourceModifyConfirm),
    #[asn(key = 28)]
    Id_PDUSessionResourceRelease(PDUSessionResourceReleaseResponse),
    #[asn(key = 29)]
    Id_PDUSessionResourceSetup(PDUSessionResourceSetupResponse),
    #[asn(key = 32)]
    Id_PWSCancel(PWSCancelResponse),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequestAcknowledge),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdateAcknowledge),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationResponse),
    #[asn(key = 41)]
    Id_UEContextRelease(UEContextReleaseComplete),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeResponse),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendResponse),
    #[asn(key = 43)]
    Id_UERadioCapabilityCheck(UERadioCapabilityCheckResponse),
    #[asn(key = 60)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingResponse),
    #[asn(key = 51)]
    Id_WriteReplaceWarning(WriteReplaceWarningResponse),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum SupportedTAItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 272)]
    Id_ConfiguredTACIndication(ConfiguredTACIndication),
    #[asn(key = 179)]
    Id_RAT_Information(RAT_Information),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedTAItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SupportedTAItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SupportedTAItemIE_Extensions(pub Vec<SupportedTAItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedMDTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedMDTIE_Extensions(pub Vec<TABasedMDTIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIIE_Extensions(pub Vec<TAIIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedMDTIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedMDTIE_Extensions(pub Vec<TAIBasedMDTIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBroadcastEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastEUTRA_ItemIE_Extensions(pub Vec<TAIBroadcastEUTRA_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBroadcastNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBroadcastNR_ItemIE_Extensions(pub Vec<TAIBroadcastNR_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAICancelledEUTRA_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledEUTRA_ItemIE_Extensions(pub Vec<TAICancelledEUTRA_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAICancelledNR_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAICancelledNR_ItemIE_Extensions(pub Vec<TAICancelledNR_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIListForInactiveItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForInactiveItemIE_Extensions(pub Vec<TAIListForInactiveItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIListForPagingItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListForPagingItemIE_Extensions(pub Vec<TAIListForPagingItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "32", sz_ub = "32")]
pub struct BIT_STRING_81(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNGF_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TNLAssociationItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TNLAssociationItemIE_Extensions(pub Vec<TNLAssociationItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TSCAssistanceInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TSCAssistanceInformationIE_Extensions(
    pub Vec<TSCAssistanceInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TSCTrafficCharacteristicsIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TSCTrafficCharacteristicsIE_Extensions(
    pub Vec<TSCTrafficCharacteristicsIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "32", sz_ub = "32")]
pub struct BIT_STRING_82(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TWIF_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TargetIDchoice_ExtensionsValue {
    #[asn(key = 178)]
    Id_TargetRNC_ID(TargetRNC_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetIDchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TargetIDchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions(
    pub Vec<TargetNGRANNode_ToSourceNGRANNode_FailureTransparentContainerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 267)]
    Id_DAPSResponseInfoList(DAPSResponseInfoList),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions(
    pub Vec<TargetNGRANNode_ToSourceNGRANNode_TransparentContainerIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRANNodeIDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRANNodeIDIE_Extensions(pub Vec<TargetRANNodeIDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRNC_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRNC_IDIE_Extensions(pub Vec<TargetRNC_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_IDIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_IDIE_Extensions(pub Vec<TargeteNB_IDIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TooearlyIntersystemHOIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TooearlyIntersystemHOIE_Extensions(pub Vec<TooearlyIntersystemHOIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TraceActivationIE_Extensions_EntryExtensionValue {
    #[asn(key = 255)]
    Id_MDTConfiguration(MDT_Configuration),
    #[asn(key = 257)]
    Id_TraceCollectionEntityURI(URI_address),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceActivationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TraceActivationIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TraceActivationIE_Extensions(pub Vec<TraceActivationIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TraceFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 44)]
    Id_NGRANTraceID(NGRANTraceID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceFailureIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceFailureIndicationProtocolIEs(pub Vec<TraceFailureIndicationProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum TraceStartProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 108)]
    Id_TraceActivation(TraceActivation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceStartProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceStartProtocolIEs(pub Vec<TraceStartProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_83(pub u8);
impl ENUMERATED_83 {
    pub const PERIODICALLY: u8 = 0u8;
    pub const ONDEMAND: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "1", ub = "3600", extensible = true)]
pub struct INTEGER_84(pub u16);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ENUMERATED_85(pub u8);
impl ENUMERATED_85 {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ENUMERATED_86(pub u8);
impl ENUMERATED_86 {
    pub const SINGLE_PACKET: u8 = 0u8;
    pub const DUAL_PACKETS: u8 = 1u8;
    pub const MULTIPLE_PACKETS: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct ENUMERATED_87(pub u8);
impl ENUMERATED_87 {
    pub const BATTERY_POWERED: u8 = 0u8;
    pub const BATTERY_POWERED_NOT_RECHARGEABLE_OR_REPLACEABLE: u8 = 1u8;
    pub const NOT_BATTERY_POWERED: u8 = 2u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_DifferentiationInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_DifferentiationInfoIE_Extensions(pub Vec<UE_DifferentiationInfoIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_NGAP_ID_pairIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_NGAP_ID_pairIE_Extensions(pub Vec<UE_NGAP_ID_pairIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_NGAP_IDschoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalNG_connectionItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_associatedLogicalNG_connectionItemIE_Extensions(
    pub Vec<UE_associatedLogicalNG_connectionItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAggregateMaximumBitRateIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAggregateMaximumBitRateIE_Extensions(
    pub Vec<UEAggregateMaximumBitRateIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationFailureProtocolIEs(
    pub Vec<UEContextModificationFailureProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 165)]
    Id_CNAssistedRANTuning(CNAssistedRANTuning),
    #[asn(key = 18)]
    Id_CoreNetworkAssistanceInformationForInactive(CoreNetworkAssistanceInformationForInactive),
    #[asn(key = 24)]
    Id_EmergencyFallbackIndicator(EmergencyFallbackIndicator),
    #[asn(key = 199)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 31)]
    Id_IndexToRFSP(IndexToRFSP),
    #[asn(key = 217)]
    Id_LTEUESidelinkAggregateMaximumBitrate(LTEUESidelinkAggregateMaximumBitrate),
    #[asn(key = 215)]
    Id_LTEV2XServicesAuthorized(LTEV2XServicesAuthorized),
    #[asn(key = 218)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 216)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 40)]
    Id_NewAMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 162)]
    Id_NewGUAMI(GUAMI),
    #[asn(key = 219)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 83)]
    Id_RANPagingPriority(RANPagingPriority),
    #[asn(key = 238)]
    Id_RGLevelWirelineAccessCharacteristics(RGLevelWirelineAccessCharacteristics),
    #[asn(key = 91)]
    Id_RRCInactiveTransitionReportRequest(RRCInactiveTransitionReportRequest),
    #[asn(key = 177)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 94)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 110)]
    Id_UEAggregateMaximumBitRate(UEAggregateMaximumBitRate),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 119)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationRequestProtocolIEs(
    pub Vec<UEContextModificationRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextModificationResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 92)]
    Id_RRCState(RRCState),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationResponseProtocolIEs(
    pub Vec<UEContextModificationResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 114)]
    Id_UE_NGAP_IDs(UE_NGAP_IDs),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCommandProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCommandProtocolIEs(pub Vec<UEContextReleaseCommandProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCompleteProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 60)]
    Id_PDUSessionResourceListCxtRelCpl(PDUSessionResourceListCxtRelCpl),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCompleteProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCompleteProtocolIEs(pub Vec<UEContextReleaseCompleteProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 133)]
    Id_PDUSessionResourceListCxtRelReq(PDUSessionResourceListCxtRelReq),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseRequestProtocolIEs(pub Vec<UEContextReleaseRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeFailureProtocolIEs(pub Vec<UEContextResumeFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 229)]
    Id_PDUSessionResourceFailedToResumeListRESReq(PDUSessionResourceFailedToResumeListRESReq),
    #[asn(key = 232)]
    Id_PDUSessionResourceResumeListRESReq(PDUSessionResourceResumeListRESReq),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 237)]
    Id_RRC_Resume_Cause(RRCEstablishmentCause),
    #[asn(key = 235)]
    Id_Suspend_Request_Indication(Suspend_Request_Indication),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestProtocolIEs(pub Vec<UEContextResumeRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestTransferIE_Extensions(
    pub Vec<UEContextResumeRequestTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextResumeResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 206)]
    Id_Extended_ConnectedTime(Extended_ConnectedTime),
    #[asn(key = 230)]
    Id_PDUSessionResourceFailedToResumeListRESRes(PDUSessionResourceFailedToResumeListRESRes),
    #[asn(key = 233)]
    Id_PDUSessionResourceResumeListRESRes(PDUSessionResourceResumeListRESRes),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 236)]
    Id_Suspend_Response_Indication(Suspend_Response_Indication),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseProtocolIEs(pub Vec<UEContextResumeResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseTransferIE_Extensions(
    pub Vec<UEContextResumeResponseTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendFailureProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 15)]
    Id_Cause(Cause),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendFailureProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendFailureProtocolIEs(pub Vec<UEContextSuspendFailureProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 32)]
    Id_InfoOnRecommendedCellsAndRANNodesForPaging(InfoOnRecommendedCellsAndRANNodesForPaging),
    #[asn(key = 231)]
    Id_PDUSessionResourceSuspendListSUSReq(PDUSessionResourceSuspendListSUSReq),
    #[asn(key = 207)]
    Id_PagingAssisDataforCEcapabUE(PagingAssisDataforCEcapabUE),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestProtocolIEs(pub Vec<UEContextSuspendRequestProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestTransferIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestTransferIE_Extensions(
    pub Vec<UEContextSuspendRequestTransferIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 93)]
    Id_SecurityContext(SecurityContext),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendResponseProtocolIEs(pub Vec<UEContextSuspendResponseProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEHistoryInformationFromTheUEchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct BIT_STRING_88(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEIdentityIndexValuechoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UEInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_AllowedNSSAI(AllowedNSSAI),
    #[asn(key = 26)]
    Id_FiveG_S_TMSI(FiveG_S_TMSI),
    #[asn(key = 210)]
    Id_NB_IoT_UEPriority(NB_IoT_UEPriority),
    #[asn(key = 148)]
    Id_S_NSSAI(S_NSSAI),
    #[asn(key = 209)]
    Id_UE_DifferentiationInfo(UE_DifferentiationInfo),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEInformationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEInformationTransferProtocolIEs(pub Vec<UEInformationTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingIdentitychoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPresenceInAreaOfInterestItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEPresenceInAreaOfInterestItemIE_Extensions(
    pub Vec<UEPresenceInAreaOfInterestItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERLFReportContainerchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityCheckRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityCheckRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityCheckRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityCheckRequestProtocolIEs(
    pub Vec<UERadioCapabilityCheckRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityCheckResponseProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 30)]
    Id_IMSVoiceSupportIndicator(IMSVoiceSupportIndicator),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityCheckResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityCheckResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityCheckResponseProtocolIEs(
    pub Vec<UERadioCapabilityCheckResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue {
    #[asn(key = 214)]
    Id_UERadioCapabilityForPagingOfNB_IoT(UERadioCapabilityForPagingOfNB_IoT),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityForPagingIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UERadioCapabilityForPagingIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityForPagingIE_Extensions(
    pub Vec<UERadioCapabilityForPagingIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 264)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityInfoIndicationProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 117)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 265)]
    Id_UERadioCapability_EUTRA_Format(UERadioCapability),
    #[asn(key = 118)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityInfoIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityInfoIndicationProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityInfoIndicationProtocolIEs(
    pub Vec<UERadioCapabilityInfoIndicationProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESecurityCapabilitiesIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESecurityCapabilitiesIE_Extensions(pub Vec<UESecurityCapabilitiesIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UETNLABindingReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UETNLABindingReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UETNLABindingReleaseRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UETNLABindingReleaseRequestProtocolIEs(
    pub Vec<UETNLABindingReleaseRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CP_SecurityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_CP_SecurityInformationIE_Extensions(
    pub Vec<UL_CP_SecurityInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 192)]
    Id_RedundantDL_NGU_UP_TNLInformation(UPTransportLayerInformation),
    #[asn(key = 195)]
    Id_RedundantUL_NGU_UP_TNLInformation(UPTransportLayerInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_NGU_UP_TNLModifyItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UL_NGU_UP_TNLModifyItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_NGU_UP_TNLModifyItemIE_Extensions(
    pub Vec<UL_NGU_UP_TNLModifyItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformationchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformationItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UPTransportLayerInformationItemIE_Extensions(
    pub Vec<UPTransportLayerInformationItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UPTransportLayerInformationPairItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UPTransportLayerInformationPairItemIE_Extensions(
    pub Vec<UPTransportLayerInformationPairItemIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnavailableGUAMIItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UnavailableGUAMIItemIE_Extensions(pub Vec<UnavailableGUAMIItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UnsuccessfulOutcomeValue {
    #[asn(key = 0)]
    Id_AMFConfigurationUpdate(AMFConfigurationUpdateFailure),
    #[asn(key = 12)]
    Id_HandoverPreparation(HandoverPreparationFailure),
    #[asn(key = 13)]
    Id_HandoverResourceAllocation(HandoverFailure),
    #[asn(key = 14)]
    Id_InitialContextSetup(InitialContextSetupFailure),
    #[asn(key = 21)]
    Id_NGSetup(NGSetupFailure),
    #[asn(key = 25)]
    Id_PathSwitchRequest(PathSwitchRequestFailure),
    #[asn(key = 35)]
    Id_RANConfigurationUpdate(RANConfigurationUpdateFailure),
    #[asn(key = 40)]
    Id_UEContextModification(UEContextModificationFailure),
    #[asn(key = 58)]
    Id_UEContextResume(UEContextResumeFailure),
    #[asn(key = 59)]
    Id_UEContextSuspend(UEContextSuspendFailure),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 38)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 121)]
    Id_UserLocationInformation(UserLocationInformation),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNASTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNASTransportProtocolIEs(pub Vec<UplinkNASTransportProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNonUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNonUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<UplinkNonUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 158)]
    Id_ENDC_SONConfigurationTransferUL(EN_DCSONConfigurationTransfer),
    #[asn(key = 251)]
    Id_IntersystemSONConfigurationTransferUL(IntersystemSONConfigurationTransfer),
    #[asn(key = 99)]
    Id_SONConfigurationTransferUL(SONConfigurationTransfer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANConfigurationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANConfigurationTransferProtocolIEs(
    pub Vec<UplinkRANConfigurationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 268)]
    Id_EarlyStatusTransfer_TransparentContainer(EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANEarlyStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANEarlyStatusTransferProtocolIEs(
    pub Vec<UplinkRANEarlyStatusTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRANStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 84)]
    Id_RANStatusTransfer_TransparentContainer(RANStatusTransfer_TransparentContainer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRANStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRANStatusTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRANStatusTransferProtocolIEs(pub Vec<UplinkRANStatusTransferProtocolIEs_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkRIMInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 175)]
    Id_RIMInformationTransfer(RIMInformationTransfer),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkRIMInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkRIMInformationTransferProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkRIMInformationTransferProtocolIEs(
    pub Vec<UplinkRIMInformationTransferProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 10)]
    Id_AMF_UE_NGAP_ID(AMF_UE_NGAP_ID),
    #[asn(key = 46)]
    Id_NRPPa_PDU(NRPPa_PDU),
    #[asn(key = 85)]
    Id_RAN_UE_NGAP_ID(RAN_UE_NGAP_ID),
    #[asn(key = 89)]
    Id_RoutingID(RoutingID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkUEAssociatedNRPPaTransportProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkUEAssociatedNRPPaTransportProtocolIEs(
    pub Vec<UplinkUEAssociatedNRPPaTransportProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationchoice_ExtensionsValue {
    #[asn(key = 244)]
    Id_UserLocationInformationTNGF(UserLocationInformationTNGF),
    #[asn(key = 248)]
    Id_UserLocationInformationTWIF(UserLocationInformationTWIF),
    #[asn(key = 243)]
    Id_UserLocationInformationW_AGF(UserLocationInformationW_AGF),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UserLocationInformationchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue {
    #[asn(key = 149)]
    Id_PSCellInformation(NGRAN_CGI),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationEUTRAIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationEUTRAIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationEUTRAIE_Extensions(
    pub Vec<UserLocationInformationEUTRAIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationN3IWFIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationN3IWFIE_Extensions(
    pub Vec<UserLocationInformationN3IWFIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationNRIE_Extensions_EntryExtensionValue {
    #[asn(key = 263)]
    Id_NID(NID),
    #[asn(key = 149)]
    Id_PSCellInformation(NGRAN_CGI),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationNRIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationNRIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationNRIE_Extensions(
    pub Vec<UserLocationInformationNRIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationTNGFIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationTNGFIE_Extensions(
    pub Vec<UserLocationInformationTNGFIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationTWIFIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationTWIFIE_Extensions(
    pub Vec<UserLocationInformationTWIFIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationW_AGFchoice_ExtensionsValue {
    #[asn(key = 275)]
    Id_GlobalCable_ID(GlobalCable_ID),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationW_AGFchoice_Extensions {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UserLocationInformationW_AGFchoice_ExtensionsValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserPlaneSecurityInformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserPlaneSecurityInformationIE_Extensions(
    pub Vec<UserPlaneSecurityInformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct OCTET_STRING_89(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct OCTET_STRING_90(pub Vec<u8>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct INTEGER_91(pub u64);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct INTEGER_92(pub u64);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct VolumeTimedReport_ItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct VolumeTimedReport_ItemIE_Extensions(pub Vec<VolumeTimedReport_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct BIT_STRING_93(pub BitVec<u8, Msb0>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct W_AGF_IDchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasConfigNameItemIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasConfigNameItemIE_Extensions(pub Vec<WLANMeasConfigNameItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_94(pub u8);
impl ENUMERATED_94 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ENUMERATED_95(pub u8);
impl ENUMERATED_95 {
    pub const TRUE: u8 = 0u8;
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasurementConfigurationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasurementConfigurationIE_Extensions(
    pub Vec<WLANMeasurementConfigurationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Assistance_InformationIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WUS_Assistance_InformationIE_Extensions(
    pub Vec<WUS_Assistance_InformationIE_Extensions_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WarningAreaListchoice_Extensions {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningRequestProtocolIEs_EntryValue {
    #[asn(key = 17)]
    Id_ConcurrentWarningMessageInd(ConcurrentWarningMessageInd),
    #[asn(key = 20)]
    Id_DataCodingScheme(DataCodingScheme),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 47)]
    Id_NumberOfBroadcastsRequested(NumberOfBroadcastsRequested),
    #[asn(key = 87)]
    Id_RepetitionPeriod(RepetitionPeriod),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 141)]
    Id_WarningAreaCoordinates(WarningAreaCoordinates),
    #[asn(key = 122)]
    Id_WarningAreaList(WarningAreaList),
    #[asn(key = 123)]
    Id_WarningMessageContents(WarningMessageContents),
    #[asn(key = 124)]
    Id_WarningSecurityInfo(WarningSecurityInfo),
    #[asn(key = 125)]
    Id_WarningType(WarningType),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningRequestProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningRequestProtocolIEs(
    pub Vec<WriteReplaceWarningRequestProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningResponseProtocolIEs_EntryValue {
    #[asn(key = 13)]
    Id_BroadcastCompletedAreaList(BroadcastCompletedAreaList),
    #[asn(key = 19)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 35)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 95)]
    Id_SerialNumber(SerialNumber),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningResponseProtocolIEs_EntryValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningResponseProtocolIEs(
    pub Vec<WriteReplaceWarningResponseProtocolIEs_Entry>,
);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "OPEN")]
pub enum XnExtTLA_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 173)]
    Id_SCTP_TLAs(SCTP_TLAs),
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct XnExtTLA_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: XnExtTLA_ItemIE_Extensions_EntryExtensionValue,
}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct XnExtTLA_ItemIE_Extensions(pub Vec<XnExtTLA_ItemIE_Extensions_Entry>);

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct XnTNLConfigurationInfoIE_Extensions_Entry {}

#[derive(asn1_codecs_derive :: AperCodec, serde :: Serialize, serde :: Deserialize, Debug)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct XnTNLConfigurationInfoIE_Extensions(pub Vec<XnTNLConfigurationInfoIE_Extensions_Entry>);

fn main() {
    use asn1_codecs::aper::*;
    eprintln!("NGAP");

    let _ = env_logger::init();

    let ngap_byte_str = "0015404a000004001b00084002f898000000000052400f06004d79206c6974746c6520674e420066001f01000000000002f8980001000800800000010002f8390001001881c00013880015400140";
    let ngap_data = hex::decode(ngap_byte_str).unwrap();
    let mut codec_data = AperCodecData::from_slice(&ngap_data);
    let ngap_pdu = NGAP_PDU::decode(&mut codec_data).unwrap();

    eprintln!("ngap_pdu: {:#?}", ngap_pdu);
    let mut encode_codec_data = AperCodecData::new();
    let result = ngap_pdu.encode(&mut encode_codec_data);
    eprintln!("result: {:#?}", result);
    let ngap_encoded_data = encode_codec_data.get_inner().unwrap();
    eprintln!("Original: {}", hex::encode(&ngap_encoded_data));
    eprintln!("Encoded: {}", ngap_byte_str);
    eprintln!("{}", ngap_data.len() == ngap_encoded_data.len());
    let ngap_pdu = NGAP_PDU::decode(&mut encode_codec_data);
    eprintln!("ngap_pdu: {:#?}", ngap_pdu);
}
